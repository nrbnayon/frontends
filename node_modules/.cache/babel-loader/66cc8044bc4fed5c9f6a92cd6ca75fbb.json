{"ast":null,"code":"import { __read } from 'tslib';\nimport { mix } from 'popmotion';\nimport { isDraggable } from '../../render/utils/is-draggable.js';\n\n/**\r\n * Reset an axis to the provided origin box.\r\n *\r\n * This is a mutative operation.\r\n */\nfunction resetAxis(axis, originAxis) {\n  axis.min = originAxis.min;\n  axis.max = originAxis.max;\n}\n/**\r\n * Reset a box to the provided origin box.\r\n *\r\n * This is a mutative operation.\r\n */\nfunction resetBox(box, originBox) {\n  resetAxis(box.x, originBox.x);\n  resetAxis(box.y, originBox.y);\n}\n/**\r\n * Scales a point based on a factor and an originPoint\r\n */\nfunction scalePoint(point, scale, originPoint) {\n  var distanceFromOrigin = point - originPoint;\n  var scaled = scale * distanceFromOrigin;\n  return originPoint + scaled;\n}\n/**\r\n * Applies a translate/scale delta to a point\r\n */\nfunction applyPointDelta(point, translate, scale, originPoint, boxScale) {\n  if (boxScale !== undefined) {\n    point = scalePoint(point, boxScale, originPoint);\n  }\n  return scalePoint(point, scale, originPoint) + translate;\n}\n/**\r\n * Applies a translate/scale delta to an axis\r\n */\nfunction applyAxisDelta(axis, translate, scale, originPoint, boxScale) {\n  if (translate === void 0) {\n    translate = 0;\n  }\n  if (scale === void 0) {\n    scale = 1;\n  }\n  axis.min = applyPointDelta(axis.min, translate, scale, originPoint, boxScale);\n  axis.max = applyPointDelta(axis.max, translate, scale, originPoint, boxScale);\n}\n/**\r\n * Applies a translate/scale delta to a box\r\n */\nfunction applyBoxDelta(box, _a) {\n  var x = _a.x,\n    y = _a.y;\n  applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);\n  applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);\n}\n/**\r\n * Apply a transform to an axis from the latest resolved motion values.\r\n * This function basically acts as a bridge between a flat motion value map\r\n * and applyAxisDelta\r\n */\nfunction applyAxisTransforms(final, axis, transforms, _a) {\n  var _b = __read(_a, 3),\n    key = _b[0],\n    scaleKey = _b[1],\n    originKey = _b[2];\n  // Copy the current axis to the final axis before mutation\n  final.min = axis.min;\n  final.max = axis.max;\n  var axisOrigin = transforms[originKey] !== undefined ? transforms[originKey] : 0.5;\n  var originPoint = mix(axis.min, axis.max, axisOrigin);\n  // Apply the axis delta to the final axis\n  applyAxisDelta(final, transforms[key], transforms[scaleKey], originPoint, transforms.scale);\n}\n/**\r\n * The names of the motion values we want to apply as translation, scale and origin.\r\n */\nvar xKeys = [\"x\", \"scaleX\", \"originX\"];\nvar yKeys = [\"y\", \"scaleY\", \"originY\"];\n/**\r\n * Apply a transform to a box from the latest resolved motion values.\r\n */\nfunction applyBoxTransforms(finalBox, box, transforms) {\n  applyAxisTransforms(finalBox.x, box.x, transforms, xKeys);\n  applyAxisTransforms(finalBox.y, box.y, transforms, yKeys);\n}\n/**\r\n * Remove a delta from a point. This is essentially the steps of applyPointDelta in reverse\r\n */\nfunction removePointDelta(point, translate, scale, originPoint, boxScale) {\n  point -= translate;\n  point = scalePoint(point, 1 / scale, originPoint);\n  if (boxScale !== undefined) {\n    point = scalePoint(point, 1 / boxScale, originPoint);\n  }\n  return point;\n}\n/**\r\n * Remove a delta from an axis. This is essentially the steps of applyAxisDelta in reverse\r\n */\nfunction removeAxisDelta(axis, translate, scale, origin, boxScale) {\n  if (translate === void 0) {\n    translate = 0;\n  }\n  if (scale === void 0) {\n    scale = 1;\n  }\n  if (origin === void 0) {\n    origin = 0.5;\n  }\n  var originPoint = mix(axis.min, axis.max, origin) - translate;\n  axis.min = removePointDelta(axis.min, translate, scale, originPoint, boxScale);\n  axis.max = removePointDelta(axis.max, translate, scale, originPoint, boxScale);\n}\n/**\r\n * Remove a transforms from an axis. This is essentially the steps of applyAxisTransforms in reverse\r\n * and acts as a bridge between motion values and removeAxisDelta\r\n */\nfunction removeAxisTransforms(axis, transforms, _a) {\n  var _b = __read(_a, 3),\n    key = _b[0],\n    scaleKey = _b[1],\n    originKey = _b[2];\n  removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale);\n}\n/**\r\n * Remove a transforms from an box. This is essentially the steps of applyAxisBox in reverse\r\n * and acts as a bridge between motion values and removeAxisDelta\r\n */\nfunction removeBoxTransforms(box, transforms) {\n  removeAxisTransforms(box.x, transforms, xKeys);\n  removeAxisTransforms(box.y, transforms, yKeys);\n}\n/**\r\n * Apply a tree of deltas to a box. We do this to calculate the effect of all the transforms\r\n * in a tree upon our box before then calculating how to project it into our desired viewport-relative box\r\n *\r\n * This is the final nested loop within updateLayoutDelta for future refactoring\r\n */\nfunction applyTreeDeltas(box, treeScale, treePath) {\n  var treeLength = treePath.length;\n  if (!treeLength) return;\n  // Reset the treeScale\n  treeScale.x = treeScale.y = 1;\n  var node;\n  var delta;\n  for (var i = 0; i < treeLength; i++) {\n    node = treePath[i];\n    delta = node.getLayoutState().delta;\n    // Incoporate each ancestor's scale into a culmulative treeScale for this component\n    treeScale.x *= delta.x.scale;\n    treeScale.y *= delta.y.scale;\n    // Apply each ancestor's calculated delta into this component's recorded layout box\n    applyBoxDelta(box, delta);\n    // If this is a draggable ancestor, also incorporate the node's transform to the layout box\n    if (isDraggable(node)) {\n      applyBoxTransforms(box, box, node.getLatestValues());\n    }\n  }\n}\nexport { applyAxisDelta, applyAxisTransforms, applyBoxDelta, applyBoxTransforms, applyPointDelta, applyTreeDeltas, removeAxisDelta, removeAxisTransforms, removeBoxTransforms, removePointDelta, resetAxis, resetBox, scalePoint };","map":{"version":3,"names":["__read","mix","isDraggable","resetAxis","axis","originAxis","min","max","resetBox","box","originBox","x","y","scalePoint","point","scale","originPoint","distanceFromOrigin","scaled","applyPointDelta","translate","boxScale","undefined","applyAxisDelta","applyBoxDelta","_a","applyAxisTransforms","final","transforms","_b","key","scaleKey","originKey","axisOrigin","xKeys","yKeys","applyBoxTransforms","finalBox","removePointDelta","removeAxisDelta","origin","removeAxisTransforms","removeBoxTransforms","applyTreeDeltas","treeScale","treePath","treeLength","length","node","delta","i","getLayoutState","getLatestValues"],"sources":["E:/Hasan sir project/4/frontend/node_modules/framer-motion/dist/es/utils/geometry/delta-apply.js"],"sourcesContent":["import { __read } from 'tslib';\r\nimport { mix } from 'popmotion';\r\nimport { isDraggable } from '../../render/utils/is-draggable.js';\r\n\r\n/**\r\n * Reset an axis to the provided origin box.\r\n *\r\n * This is a mutative operation.\r\n */\r\nfunction resetAxis(axis, originAxis) {\r\n    axis.min = originAxis.min;\r\n    axis.max = originAxis.max;\r\n}\r\n/**\r\n * Reset a box to the provided origin box.\r\n *\r\n * This is a mutative operation.\r\n */\r\nfunction resetBox(box, originBox) {\r\n    resetAxis(box.x, originBox.x);\r\n    resetAxis(box.y, originBox.y);\r\n}\r\n/**\r\n * Scales a point based on a factor and an originPoint\r\n */\r\nfunction scalePoint(point, scale, originPoint) {\r\n    var distanceFromOrigin = point - originPoint;\r\n    var scaled = scale * distanceFromOrigin;\r\n    return originPoint + scaled;\r\n}\r\n/**\r\n * Applies a translate/scale delta to a point\r\n */\r\nfunction applyPointDelta(point, translate, scale, originPoint, boxScale) {\r\n    if (boxScale !== undefined) {\r\n        point = scalePoint(point, boxScale, originPoint);\r\n    }\r\n    return scalePoint(point, scale, originPoint) + translate;\r\n}\r\n/**\r\n * Applies a translate/scale delta to an axis\r\n */\r\nfunction applyAxisDelta(axis, translate, scale, originPoint, boxScale) {\r\n    if (translate === void 0) { translate = 0; }\r\n    if (scale === void 0) { scale = 1; }\r\n    axis.min = applyPointDelta(axis.min, translate, scale, originPoint, boxScale);\r\n    axis.max = applyPointDelta(axis.max, translate, scale, originPoint, boxScale);\r\n}\r\n/**\r\n * Applies a translate/scale delta to a box\r\n */\r\nfunction applyBoxDelta(box, _a) {\r\n    var x = _a.x, y = _a.y;\r\n    applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);\r\n    applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);\r\n}\r\n/**\r\n * Apply a transform to an axis from the latest resolved motion values.\r\n * This function basically acts as a bridge between a flat motion value map\r\n * and applyAxisDelta\r\n */\r\nfunction applyAxisTransforms(final, axis, transforms, _a) {\r\n    var _b = __read(_a, 3), key = _b[0], scaleKey = _b[1], originKey = _b[2];\r\n    // Copy the current axis to the final axis before mutation\r\n    final.min = axis.min;\r\n    final.max = axis.max;\r\n    var axisOrigin = transforms[originKey] !== undefined ? transforms[originKey] : 0.5;\r\n    var originPoint = mix(axis.min, axis.max, axisOrigin);\r\n    // Apply the axis delta to the final axis\r\n    applyAxisDelta(final, transforms[key], transforms[scaleKey], originPoint, transforms.scale);\r\n}\r\n/**\r\n * The names of the motion values we want to apply as translation, scale and origin.\r\n */\r\nvar xKeys = [\"x\", \"scaleX\", \"originX\"];\r\nvar yKeys = [\"y\", \"scaleY\", \"originY\"];\r\n/**\r\n * Apply a transform to a box from the latest resolved motion values.\r\n */\r\nfunction applyBoxTransforms(finalBox, box, transforms) {\r\n    applyAxisTransforms(finalBox.x, box.x, transforms, xKeys);\r\n    applyAxisTransforms(finalBox.y, box.y, transforms, yKeys);\r\n}\r\n/**\r\n * Remove a delta from a point. This is essentially the steps of applyPointDelta in reverse\r\n */\r\nfunction removePointDelta(point, translate, scale, originPoint, boxScale) {\r\n    point -= translate;\r\n    point = scalePoint(point, 1 / scale, originPoint);\r\n    if (boxScale !== undefined) {\r\n        point = scalePoint(point, 1 / boxScale, originPoint);\r\n    }\r\n    return point;\r\n}\r\n/**\r\n * Remove a delta from an axis. This is essentially the steps of applyAxisDelta in reverse\r\n */\r\nfunction removeAxisDelta(axis, translate, scale, origin, boxScale) {\r\n    if (translate === void 0) { translate = 0; }\r\n    if (scale === void 0) { scale = 1; }\r\n    if (origin === void 0) { origin = 0.5; }\r\n    var originPoint = mix(axis.min, axis.max, origin) - translate;\r\n    axis.min = removePointDelta(axis.min, translate, scale, originPoint, boxScale);\r\n    axis.max = removePointDelta(axis.max, translate, scale, originPoint, boxScale);\r\n}\r\n/**\r\n * Remove a transforms from an axis. This is essentially the steps of applyAxisTransforms in reverse\r\n * and acts as a bridge between motion values and removeAxisDelta\r\n */\r\nfunction removeAxisTransforms(axis, transforms, _a) {\r\n    var _b = __read(_a, 3), key = _b[0], scaleKey = _b[1], originKey = _b[2];\r\n    removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale);\r\n}\r\n/**\r\n * Remove a transforms from an box. This is essentially the steps of applyAxisBox in reverse\r\n * and acts as a bridge between motion values and removeAxisDelta\r\n */\r\nfunction removeBoxTransforms(box, transforms) {\r\n    removeAxisTransforms(box.x, transforms, xKeys);\r\n    removeAxisTransforms(box.y, transforms, yKeys);\r\n}\r\n/**\r\n * Apply a tree of deltas to a box. We do this to calculate the effect of all the transforms\r\n * in a tree upon our box before then calculating how to project it into our desired viewport-relative box\r\n *\r\n * This is the final nested loop within updateLayoutDelta for future refactoring\r\n */\r\nfunction applyTreeDeltas(box, treeScale, treePath) {\r\n    var treeLength = treePath.length;\r\n    if (!treeLength)\r\n        return;\r\n    // Reset the treeScale\r\n    treeScale.x = treeScale.y = 1;\r\n    var node;\r\n    var delta;\r\n    for (var i = 0; i < treeLength; i++) {\r\n        node = treePath[i];\r\n        delta = node.getLayoutState().delta;\r\n        // Incoporate each ancestor's scale into a culmulative treeScale for this component\r\n        treeScale.x *= delta.x.scale;\r\n        treeScale.y *= delta.y.scale;\r\n        // Apply each ancestor's calculated delta into this component's recorded layout box\r\n        applyBoxDelta(box, delta);\r\n        // If this is a draggable ancestor, also incorporate the node's transform to the layout box\r\n        if (isDraggable(node)) {\r\n            applyBoxTransforms(box, box, node.getLatestValues());\r\n        }\r\n    }\r\n}\r\n\r\nexport { applyAxisDelta, applyAxisTransforms, applyBoxDelta, applyBoxTransforms, applyPointDelta, applyTreeDeltas, removeAxisDelta, removeAxisTransforms, removeBoxTransforms, removePointDelta, resetAxis, resetBox, scalePoint };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}