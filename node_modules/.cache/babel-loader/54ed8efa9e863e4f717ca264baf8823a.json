{"ast":null,"code":"import { mix, distance, clamp, progress } from 'popmotion';\nvar clampProgress = function (v) {\n  return clamp(0, 1, v);\n};\n/**\r\n * Returns true if the provided value is within maxDistance of the provided target\r\n */\nfunction isNear(value, target, maxDistance) {\n  if (target === void 0) {\n    target = 0;\n  }\n  if (maxDistance === void 0) {\n    maxDistance = 0.01;\n  }\n  return distance(value, target) < maxDistance;\n}\nfunction calcLength(axis) {\n  return axis.max - axis.min;\n}\n/**\r\n * Calculate a transform origin relative to the source axis, between 0-1, that results\r\n * in an asthetically pleasing scale/transform needed to project from source to target.\r\n */\nfunction calcOrigin(source, target) {\n  var origin = 0.5;\n  var sourceLength = calcLength(source);\n  var targetLength = calcLength(target);\n  if (targetLength > sourceLength) {\n    origin = progress(target.min, target.max - sourceLength, source.min);\n  } else if (sourceLength > targetLength) {\n    origin = progress(source.min, source.max - targetLength, target.min);\n  }\n  return clampProgress(origin);\n}\n/**\r\n * Update the AxisDelta with a transform that projects source into target.\r\n *\r\n * The transform `origin` is optional. If not provided, it'll be automatically\r\n * calculated based on the relative positions of the two bounding boxes.\r\n */\nfunction updateAxisDelta(delta, source, target, origin) {\n  if (origin === void 0) {\n    origin = 0.5;\n  }\n  delta.origin = origin;\n  delta.originPoint = mix(source.min, source.max, delta.origin);\n  delta.scale = calcLength(target) / calcLength(source);\n  if (isNear(delta.scale, 1, 0.0001)) delta.scale = 1;\n  delta.translate = mix(target.min, target.max, delta.origin) - delta.originPoint;\n  if (isNear(delta.translate)) delta.translate = 0;\n}\n/**\r\n * Update the BoxDelta with a transform that projects the source into the target.\r\n *\r\n * The transform `origin` is optional. If not provided, it'll be automatically\r\n * calculated based on the relative positions of the two bounding boxes.\r\n */\nfunction updateBoxDelta(delta, source, target, origin) {\n  updateAxisDelta(delta.x, source.x, target.x, defaultOrigin(origin.originX));\n  updateAxisDelta(delta.y, source.y, target.y, defaultOrigin(origin.originY));\n}\n/**\r\n * Currently this only accepts numerical origins, measured as 0-1, but could\r\n * accept pixel values by comparing to the target axis.\r\n */\nfunction defaultOrigin(origin) {\n  return typeof origin === \"number\" ? origin : 0.5;\n}\nfunction calcRelativeAxis(target, relative, parent) {\n  target.min = parent.min + relative.min;\n  target.max = target.min + calcLength(relative);\n}\nfunction calcRelativeBox(projection, parentProjection) {\n  calcRelativeAxis(projection.target.x, projection.relativeTarget.x, parentProjection.target.x);\n  calcRelativeAxis(projection.target.y, projection.relativeTarget.y, parentProjection.target.y);\n}\nexport { calcOrigin, calcRelativeAxis, calcRelativeBox, isNear, updateAxisDelta, updateBoxDelta };","map":{"version":3,"names":["mix","distance","clamp","progress","clampProgress","v","isNear","value","target","maxDistance","calcLength","axis","max","min","calcOrigin","source","origin","sourceLength","targetLength","updateAxisDelta","delta","originPoint","scale","translate","updateBoxDelta","x","defaultOrigin","originX","y","originY","calcRelativeAxis","relative","parent","calcRelativeBox","projection","parentProjection","relativeTarget"],"sources":["E:/Hasan sir project/4/frontend/node_modules/framer-motion/dist/es/utils/geometry/delta-calc.js"],"sourcesContent":["import { mix, distance, clamp, progress } from 'popmotion';\r\n\r\nvar clampProgress = function (v) { return clamp(0, 1, v); };\r\n/**\r\n * Returns true if the provided value is within maxDistance of the provided target\r\n */\r\nfunction isNear(value, target, maxDistance) {\r\n    if (target === void 0) { target = 0; }\r\n    if (maxDistance === void 0) { maxDistance = 0.01; }\r\n    return distance(value, target) < maxDistance;\r\n}\r\nfunction calcLength(axis) {\r\n    return axis.max - axis.min;\r\n}\r\n/**\r\n * Calculate a transform origin relative to the source axis, between 0-1, that results\r\n * in an asthetically pleasing scale/transform needed to project from source to target.\r\n */\r\nfunction calcOrigin(source, target) {\r\n    var origin = 0.5;\r\n    var sourceLength = calcLength(source);\r\n    var targetLength = calcLength(target);\r\n    if (targetLength > sourceLength) {\r\n        origin = progress(target.min, target.max - sourceLength, source.min);\r\n    }\r\n    else if (sourceLength > targetLength) {\r\n        origin = progress(source.min, source.max - targetLength, target.min);\r\n    }\r\n    return clampProgress(origin);\r\n}\r\n/**\r\n * Update the AxisDelta with a transform that projects source into target.\r\n *\r\n * The transform `origin` is optional. If not provided, it'll be automatically\r\n * calculated based on the relative positions of the two bounding boxes.\r\n */\r\nfunction updateAxisDelta(delta, source, target, origin) {\r\n    if (origin === void 0) { origin = 0.5; }\r\n    delta.origin = origin;\r\n    delta.originPoint = mix(source.min, source.max, delta.origin);\r\n    delta.scale = calcLength(target) / calcLength(source);\r\n    if (isNear(delta.scale, 1, 0.0001))\r\n        delta.scale = 1;\r\n    delta.translate =\r\n        mix(target.min, target.max, delta.origin) - delta.originPoint;\r\n    if (isNear(delta.translate))\r\n        delta.translate = 0;\r\n}\r\n/**\r\n * Update the BoxDelta with a transform that projects the source into the target.\r\n *\r\n * The transform `origin` is optional. If not provided, it'll be automatically\r\n * calculated based on the relative positions of the two bounding boxes.\r\n */\r\nfunction updateBoxDelta(delta, source, target, origin) {\r\n    updateAxisDelta(delta.x, source.x, target.x, defaultOrigin(origin.originX));\r\n    updateAxisDelta(delta.y, source.y, target.y, defaultOrigin(origin.originY));\r\n}\r\n/**\r\n * Currently this only accepts numerical origins, measured as 0-1, but could\r\n * accept pixel values by comparing to the target axis.\r\n */\r\nfunction defaultOrigin(origin) {\r\n    return typeof origin === \"number\" ? origin : 0.5;\r\n}\r\nfunction calcRelativeAxis(target, relative, parent) {\r\n    target.min = parent.min + relative.min;\r\n    target.max = target.min + calcLength(relative);\r\n}\r\nfunction calcRelativeBox(projection, parentProjection) {\r\n    calcRelativeAxis(projection.target.x, projection.relativeTarget.x, parentProjection.target.x);\r\n    calcRelativeAxis(projection.target.y, projection.relativeTarget.y, parentProjection.target.y);\r\n}\r\n\r\nexport { calcOrigin, calcRelativeAxis, calcRelativeBox, isNear, updateAxisDelta, updateBoxDelta };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}