{"ast":null,"code":"import { zeroLayout } from '../../utils/state.js';\n\n/**\r\n * Build a transform style that takes a calculated delta between the element's current\r\n * space on screen and projects it into the desired space.\r\n */\nfunction buildLayoutProjectionTransform(_a, treeScale, latestTransform) {\n  var x = _a.x,\n    y = _a.y;\n  /**\r\n   * The translations we use to calculate are always relative to the viewport coordinate space.\r\n   * But when we apply scales, we also scale the coordinate space of an element and its children.\r\n   * For instance if we have a treeScale (the culmination of all parent scales) of 0.5 and we need\r\n   * to move an element 100 pixels, we actually need to move it 200 in within that scaled space.\r\n   */\n  var xTranslate = x.translate / treeScale.x;\n  var yTranslate = y.translate / treeScale.y;\n  var transform = \"translate3d(\" + xTranslate + \"px, \" + yTranslate + \"px, 0) \";\n  if (latestTransform) {\n    var rotate = latestTransform.rotate,\n      rotateX = latestTransform.rotateX,\n      rotateY = latestTransform.rotateY;\n    if (rotate) transform += \"rotate(\" + rotate + \") \";\n    if (rotateX) transform += \"rotateX(\" + rotateX + \") \";\n    if (rotateY) transform += \"rotateY(\" + rotateY + \") \";\n  }\n  transform += \"scale(\" + x.scale + \", \" + y.scale + \")\";\n  return !latestTransform && transform === identityProjection ? \"\" : transform;\n}\n/**\r\n * Take the calculated delta origin and apply it as a transform string.\r\n */\nfunction buildLayoutProjectionTransformOrigin(_a) {\n  var deltaFinal = _a.deltaFinal;\n  return deltaFinal.x.origin * 100 + \"% \" + deltaFinal.y.origin * 100 + \"% 0\";\n}\nvar identityProjection = buildLayoutProjectionTransform(zeroLayout.delta, zeroLayout.treeScale, {\n  x: 1,\n  y: 1\n});\nexport { buildLayoutProjectionTransform, buildLayoutProjectionTransformOrigin, identityProjection };","map":{"version":3,"names":["zeroLayout","buildLayoutProjectionTransform","_a","treeScale","latestTransform","x","y","xTranslate","translate","yTranslate","transform","rotate","rotateX","rotateY","scale","identityProjection","buildLayoutProjectionTransformOrigin","deltaFinal","origin","delta"],"sources":["E:/Hasan sir project/4/frontend/node_modules/framer-motion/dist/es/render/html/utils/build-projection-transform.js"],"sourcesContent":["import { zeroLayout } from '../../utils/state.js';\r\n\r\n/**\r\n * Build a transform style that takes a calculated delta between the element's current\r\n * space on screen and projects it into the desired space.\r\n */\r\nfunction buildLayoutProjectionTransform(_a, treeScale, latestTransform) {\r\n    var x = _a.x, y = _a.y;\r\n    /**\r\n     * The translations we use to calculate are always relative to the viewport coordinate space.\r\n     * But when we apply scales, we also scale the coordinate space of an element and its children.\r\n     * For instance if we have a treeScale (the culmination of all parent scales) of 0.5 and we need\r\n     * to move an element 100 pixels, we actually need to move it 200 in within that scaled space.\r\n     */\r\n    var xTranslate = x.translate / treeScale.x;\r\n    var yTranslate = y.translate / treeScale.y;\r\n    var transform = \"translate3d(\" + xTranslate + \"px, \" + yTranslate + \"px, 0) \";\r\n    if (latestTransform) {\r\n        var rotate = latestTransform.rotate, rotateX = latestTransform.rotateX, rotateY = latestTransform.rotateY;\r\n        if (rotate)\r\n            transform += \"rotate(\" + rotate + \") \";\r\n        if (rotateX)\r\n            transform += \"rotateX(\" + rotateX + \") \";\r\n        if (rotateY)\r\n            transform += \"rotateY(\" + rotateY + \") \";\r\n    }\r\n    transform += \"scale(\" + x.scale + \", \" + y.scale + \")\";\r\n    return !latestTransform && transform === identityProjection ? \"\" : transform;\r\n}\r\n/**\r\n * Take the calculated delta origin and apply it as a transform string.\r\n */\r\nfunction buildLayoutProjectionTransformOrigin(_a) {\r\n    var deltaFinal = _a.deltaFinal;\r\n    return deltaFinal.x.origin * 100 + \"% \" + deltaFinal.y.origin * 100 + \"% 0\";\r\n}\r\nvar identityProjection = buildLayoutProjectionTransform(zeroLayout.delta, zeroLayout.treeScale, { x: 1, y: 1 });\r\n\r\nexport { buildLayoutProjectionTransform, buildLayoutProjectionTransformOrigin, identityProjection };\r\n"],"mappings":"AAAA,SAASA,UAAU,QAAQ,sBAAsB;;AAEjD;AACA;AACA;AACA;AACA,SAASC,8BAA8BA,CAACC,EAAE,EAAEC,SAAS,EAAEC,eAAe,EAAE;EACpE,IAAIC,CAAC,GAAGH,EAAE,CAACG,CAAC;IAAEC,CAAC,GAAGJ,EAAE,CAACI,CAAC;EACtB;AACJ;AACA;AACA;AACA;AACA;EACI,IAAIC,UAAU,GAAGF,CAAC,CAACG,SAAS,GAAGL,SAAS,CAACE,CAAC;EAC1C,IAAII,UAAU,GAAGH,CAAC,CAACE,SAAS,GAAGL,SAAS,CAACG,CAAC;EAC1C,IAAII,SAAS,GAAG,cAAc,GAAGH,UAAU,GAAG,MAAM,GAAGE,UAAU,GAAG,SAAS;EAC7E,IAAIL,eAAe,EAAE;IACjB,IAAIO,MAAM,GAAGP,eAAe,CAACO,MAAM;MAAEC,OAAO,GAAGR,eAAe,CAACQ,OAAO;MAAEC,OAAO,GAAGT,eAAe,CAACS,OAAO;IACzG,IAAIF,MAAM,EACND,SAAS,IAAI,SAAS,GAAGC,MAAM,GAAG,IAAI;IAC1C,IAAIC,OAAO,EACPF,SAAS,IAAI,UAAU,GAAGE,OAAO,GAAG,IAAI;IAC5C,IAAIC,OAAO,EACPH,SAAS,IAAI,UAAU,GAAGG,OAAO,GAAG,IAAI;EAChD;EACAH,SAAS,IAAI,QAAQ,GAAGL,CAAC,CAACS,KAAK,GAAG,IAAI,GAAGR,CAAC,CAACQ,KAAK,GAAG,GAAG;EACtD,OAAO,CAACV,eAAe,IAAIM,SAAS,KAAKK,kBAAkB,GAAG,EAAE,GAAGL,SAAS;AAChF;AACA;AACA;AACA;AACA,SAASM,oCAAoCA,CAACd,EAAE,EAAE;EAC9C,IAAIe,UAAU,GAAGf,EAAE,CAACe,UAAU;EAC9B,OAAOA,UAAU,CAACZ,CAAC,CAACa,MAAM,GAAG,GAAG,GAAG,IAAI,GAAGD,UAAU,CAACX,CAAC,CAACY,MAAM,GAAG,GAAG,GAAG,KAAK;AAC/E;AACA,IAAIH,kBAAkB,GAAGd,8BAA8B,CAACD,UAAU,CAACmB,KAAK,EAAEnB,UAAU,CAACG,SAAS,EAAE;EAAEE,CAAC,EAAE,CAAC;EAAEC,CAAC,EAAE;AAAE,CAAC,CAAC;AAE/G,SAASL,8BAA8B,EAAEe,oCAAoC,EAAED,kBAAkB"},"metadata":{},"sourceType":"module"}