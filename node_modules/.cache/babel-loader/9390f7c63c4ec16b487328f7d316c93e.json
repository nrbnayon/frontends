{"ast":null,"code":"import sync from 'framesync';\nimport { copyAxisBox } from '../../../utils/geometry/index.js';\nimport { compareByDepth } from '../../utils/compare-by-depth.js';\nfunction isProjecting(visualElement) {\n  var isEnabled = visualElement.projection.isEnabled;\n  return isEnabled || visualElement.shouldResetTransform();\n}\nfunction collectProjectingAncestors(visualElement, ancestors) {\n  if (ancestors === void 0) {\n    ancestors = [];\n  }\n  var parent = visualElement.parent;\n  if (parent) collectProjectingAncestors(parent, ancestors);\n  if (isProjecting(visualElement)) ancestors.push(visualElement);\n  return ancestors;\n}\nfunction collectProjectingChildren(visualElement) {\n  var children = [];\n  var addChild = function (child) {\n    if (isProjecting(child)) children.push(child);\n    child.children.forEach(addChild);\n  };\n  visualElement.children.forEach(addChild);\n  return children.sort(compareByDepth);\n}\n/**\r\n * Update the layoutState by measuring the DOM layout. This\r\n * should be called after resetting any layout-affecting transforms.\r\n */\nfunction updateLayoutMeasurement(visualElement) {\n  if (visualElement.shouldResetTransform()) return;\n  var layoutState = visualElement.getLayoutState();\n  visualElement.notifyBeforeLayoutMeasure(layoutState.layout);\n  layoutState.isHydrated = true;\n  layoutState.layout = visualElement.measureViewportBox();\n  layoutState.layoutCorrected = copyAxisBox(layoutState.layout);\n  visualElement.notifyLayoutMeasure(layoutState.layout, visualElement.prevViewportBox || layoutState.layout);\n  sync.update(function () {\n    return visualElement.rebaseProjectionTarget();\n  });\n}\n/**\r\n * Record the viewport box as it was before an expected mutation/re-render\r\n */\nfunction snapshotViewportBox(visualElement) {\n  if (visualElement.shouldResetTransform()) return;\n  visualElement.prevViewportBox = visualElement.measureViewportBox(false);\n  /**\r\n   * Update targetBox to match the prevViewportBox. This is just to ensure\r\n   * that targetBox is affected by scroll in the same way as the measured box\r\n   */\n  visualElement.rebaseProjectionTarget(false, visualElement.prevViewportBox);\n}\nexport { collectProjectingAncestors, collectProjectingChildren, snapshotViewportBox, updateLayoutMeasurement };","map":{"version":3,"names":["sync","copyAxisBox","compareByDepth","isProjecting","visualElement","isEnabled","projection","shouldResetTransform","collectProjectingAncestors","ancestors","parent","push","collectProjectingChildren","children","addChild","child","forEach","sort","updateLayoutMeasurement","layoutState","getLayoutState","notifyBeforeLayoutMeasure","layout","isHydrated","measureViewportBox","layoutCorrected","notifyLayoutMeasure","prevViewportBox","update","rebaseProjectionTarget","snapshotViewportBox"],"sources":["E:/Hasan sir project/ChattersTwo/frontend/node_modules/framer-motion/dist/es/render/dom/projection/utils.js"],"sourcesContent":["import sync from 'framesync';\r\nimport { copyAxisBox } from '../../../utils/geometry/index.js';\r\nimport { compareByDepth } from '../../utils/compare-by-depth.js';\r\n\r\nfunction isProjecting(visualElement) {\r\n    var isEnabled = visualElement.projection.isEnabled;\r\n    return isEnabled || visualElement.shouldResetTransform();\r\n}\r\nfunction collectProjectingAncestors(visualElement, ancestors) {\r\n    if (ancestors === void 0) { ancestors = []; }\r\n    var parent = visualElement.parent;\r\n    if (parent)\r\n        collectProjectingAncestors(parent, ancestors);\r\n    if (isProjecting(visualElement))\r\n        ancestors.push(visualElement);\r\n    return ancestors;\r\n}\r\nfunction collectProjectingChildren(visualElement) {\r\n    var children = [];\r\n    var addChild = function (child) {\r\n        if (isProjecting(child))\r\n            children.push(child);\r\n        child.children.forEach(addChild);\r\n    };\r\n    visualElement.children.forEach(addChild);\r\n    return children.sort(compareByDepth);\r\n}\r\n/**\r\n * Update the layoutState by measuring the DOM layout. This\r\n * should be called after resetting any layout-affecting transforms.\r\n */\r\nfunction updateLayoutMeasurement(visualElement) {\r\n    if (visualElement.shouldResetTransform())\r\n        return;\r\n    var layoutState = visualElement.getLayoutState();\r\n    visualElement.notifyBeforeLayoutMeasure(layoutState.layout);\r\n    layoutState.isHydrated = true;\r\n    layoutState.layout = visualElement.measureViewportBox();\r\n    layoutState.layoutCorrected = copyAxisBox(layoutState.layout);\r\n    visualElement.notifyLayoutMeasure(layoutState.layout, visualElement.prevViewportBox || layoutState.layout);\r\n    sync.update(function () { return visualElement.rebaseProjectionTarget(); });\r\n}\r\n/**\r\n * Record the viewport box as it was before an expected mutation/re-render\r\n */\r\nfunction snapshotViewportBox(visualElement) {\r\n    if (visualElement.shouldResetTransform())\r\n        return;\r\n    visualElement.prevViewportBox = visualElement.measureViewportBox(false);\r\n    /**\r\n     * Update targetBox to match the prevViewportBox. This is just to ensure\r\n     * that targetBox is affected by scroll in the same way as the measured box\r\n     */\r\n    visualElement.rebaseProjectionTarget(false, visualElement.prevViewportBox);\r\n}\r\n\r\nexport { collectProjectingAncestors, collectProjectingChildren, snapshotViewportBox, updateLayoutMeasurement };\r\n"],"mappings":"AAAA,OAAOA,IAAI,MAAM,WAAW;AAC5B,SAASC,WAAW,QAAQ,kCAAkC;AAC9D,SAASC,cAAc,QAAQ,iCAAiC;AAEhE,SAASC,YAAYA,CAACC,aAAa,EAAE;EACjC,IAAIC,SAAS,GAAGD,aAAa,CAACE,UAAU,CAACD,SAAS;EAClD,OAAOA,SAAS,IAAID,aAAa,CAACG,oBAAoB,CAAC,CAAC;AAC5D;AACA,SAASC,0BAA0BA,CAACJ,aAAa,EAAEK,SAAS,EAAE;EAC1D,IAAIA,SAAS,KAAK,KAAK,CAAC,EAAE;IAAEA,SAAS,GAAG,EAAE;EAAE;EAC5C,IAAIC,MAAM,GAAGN,aAAa,CAACM,MAAM;EACjC,IAAIA,MAAM,EACNF,0BAA0B,CAACE,MAAM,EAAED,SAAS,CAAC;EACjD,IAAIN,YAAY,CAACC,aAAa,CAAC,EAC3BK,SAAS,CAACE,IAAI,CAACP,aAAa,CAAC;EACjC,OAAOK,SAAS;AACpB;AACA,SAASG,yBAAyBA,CAACR,aAAa,EAAE;EAC9C,IAAIS,QAAQ,GAAG,EAAE;EACjB,IAAIC,QAAQ,GAAG,SAAAA,CAAUC,KAAK,EAAE;IAC5B,IAAIZ,YAAY,CAACY,KAAK,CAAC,EACnBF,QAAQ,CAACF,IAAI,CAACI,KAAK,CAAC;IACxBA,KAAK,CAACF,QAAQ,CAACG,OAAO,CAACF,QAAQ,CAAC;EACpC,CAAC;EACDV,aAAa,CAACS,QAAQ,CAACG,OAAO,CAACF,QAAQ,CAAC;EACxC,OAAOD,QAAQ,CAACI,IAAI,CAACf,cAAc,CAAC;AACxC;AACA;AACA;AACA;AACA;AACA,SAASgB,uBAAuBA,CAACd,aAAa,EAAE;EAC5C,IAAIA,aAAa,CAACG,oBAAoB,CAAC,CAAC,EACpC;EACJ,IAAIY,WAAW,GAAGf,aAAa,CAACgB,cAAc,CAAC,CAAC;EAChDhB,aAAa,CAACiB,yBAAyB,CAACF,WAAW,CAACG,MAAM,CAAC;EAC3DH,WAAW,CAACI,UAAU,GAAG,IAAI;EAC7BJ,WAAW,CAACG,MAAM,GAAGlB,aAAa,CAACoB,kBAAkB,CAAC,CAAC;EACvDL,WAAW,CAACM,eAAe,GAAGxB,WAAW,CAACkB,WAAW,CAACG,MAAM,CAAC;EAC7DlB,aAAa,CAACsB,mBAAmB,CAACP,WAAW,CAACG,MAAM,EAAElB,aAAa,CAACuB,eAAe,IAAIR,WAAW,CAACG,MAAM,CAAC;EAC1GtB,IAAI,CAAC4B,MAAM,CAAC,YAAY;IAAE,OAAOxB,aAAa,CAACyB,sBAAsB,CAAC,CAAC;EAAE,CAAC,CAAC;AAC/E;AACA;AACA;AACA;AACA,SAASC,mBAAmBA,CAAC1B,aAAa,EAAE;EACxC,IAAIA,aAAa,CAACG,oBAAoB,CAAC,CAAC,EACpC;EACJH,aAAa,CAACuB,eAAe,GAAGvB,aAAa,CAACoB,kBAAkB,CAAC,KAAK,CAAC;EACvE;AACJ;AACA;AACA;EACIpB,aAAa,CAACyB,sBAAsB,CAAC,KAAK,EAAEzB,aAAa,CAACuB,eAAe,CAAC;AAC9E;AAEA,SAASnB,0BAA0B,EAAEI,yBAAyB,EAAEkB,mBAAmB,EAAEZ,uBAAuB"},"metadata":{},"sourceType":"module"}