{"ast":null,"code":"import { contains, focus, getActiveElement, isTabbable } from \"@chakra-ui/utils\";\nimport { useUpdateEffect } from \"./use-update-effect\";\nfunction preventReturnFocus(containerRef) {\n  var el = containerRef.current;\n  if (!el) return false;\n  var activeElement = getActiveElement(el);\n  if (!activeElement) return false;\n  if (contains(el, activeElement)) return false;\n  if (isTabbable(activeElement)) return true;\n  return false;\n}\n/**\r\n * Popover hook to manage the focus when the popover closes or hides.\r\n *\r\n * We either want to return focus back to the popover trigger or\r\n * let focus proceed normally if user moved to another interactive\r\n * element in the viewport.\r\n */\n\nexport function useFocusOnHide(containerRef, options) {\n  var {\n    shouldFocus: shouldFocusProp,\n    visible,\n    focusRef\n  } = options;\n  var shouldFocus = shouldFocusProp && !visible;\n  useUpdateEffect(() => {\n    if (!shouldFocus) return;\n    if (preventReturnFocus(containerRef)) {\n      return;\n    }\n    var el = (focusRef == null ? void 0 : focusRef.current) || containerRef.current;\n    if (el) {\n      focus(el, {\n        nextTick: true\n      });\n    }\n  }, [shouldFocus, containerRef, focusRef]);\n}","map":{"version":3,"names":["contains","focus","getActiveElement","isTabbable","useUpdateEffect","preventReturnFocus","containerRef","el","current","activeElement","useFocusOnHide","options","shouldFocus","shouldFocusProp","visible","focusRef","nextTick"],"sources":["../../src/use-focus-on-hide.ts"],"sourcesContent":["import {\n  contains,\n  focus,\n  FocusableElement,\n  getActiveElement,\n  isTabbable,\n} from \"@chakra-ui/utils\"\nimport { RefObject } from \"react\"\nimport { useUpdateEffect } from \"./use-update-effect\"\n\nexport interface UseFocusOnHideOptions {\n  focusRef: RefObject<FocusableElement>\n  shouldFocus?: boolean\n  visible?: boolean\n}\n\nfunction preventReturnFocus(containerRef: React.RefObject<HTMLElement>) {\n  const el = containerRef.current\n  if (!el) return false\n\n  const activeElement = getActiveElement(el)\n\n  if (!activeElement) return false\n  if (contains(el, activeElement)) return false\n  if (isTabbable(activeElement)) return true\n\n  return false\n}\n\n/**\n * Popover hook to manage the focus when the popover closes or hides.\n *\n * We either want to return focus back to the popover trigger or\n * let focus proceed normally if user moved to another interactive\n * element in the viewport.\n */\nexport function useFocusOnHide(\n  containerRef: RefObject<HTMLElement>,\n  options: UseFocusOnHideOptions,\n) {\n  const { shouldFocus: shouldFocusProp, visible, focusRef } = options\n\n  const shouldFocus = shouldFocusProp && !visible\n\n  useUpdateEffect(() => {\n    if (!shouldFocus) return\n\n    if (preventReturnFocus(containerRef)) {\n      return\n    }\n\n    const el = focusRef?.current || containerRef.current\n\n    if (el) {\n      focus(el, { nextTick: true })\n    }\n  }, [shouldFocus, containerRef, focusRef])\n}\n"],"mappings":"AAAA,SACEA,QADF,EAEEC,KAFF,EAIEC,gBAJF,EAKEC,UALF,QAMO,kBANP;AAQA,SAASC,eAAT,QAAgC,qBAAhC;AAQA,SAASC,kBAATA,CAA4BC,YAA5B,EAAwE;EACtE,IAAMC,EAAE,GAAGD,YAAY,CAACE,OAAxB;EACA,IAAI,CAACD,EAAL,EAAS,OAAO,KAAP;EAET,IAAME,aAAa,GAAGP,gBAAgB,CAACK,EAAD,CAAtC;EAEA,IAAI,CAACE,aAAL,EAAoB,OAAO,KAAP;EACpB,IAAIT,QAAQ,CAACO,EAAD,EAAKE,aAAL,CAAZ,EAAiC,OAAO,KAAP;EACjC,IAAIN,UAAU,CAACM,aAAD,CAAd,EAA+B,OAAO,IAAP;EAE/B,OAAO,KAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,cAATA,CACLJ,YADK,EAELK,OAFK,EAGL;EACA,IAAM;IAAEC,WAAW,EAAEC,eAAf;IAAgCC,OAAhC;IAAyCC;EAAzC,IAAsDJ,OAA5D;EAEA,IAAMC,WAAW,GAAGC,eAAe,IAAI,CAACC,OAAxC;EAEAV,eAAe,CAAC,MAAM;IACpB,IAAI,CAACQ,WAAL,EAAkB;IAElB,IAAIP,kBAAkB,CAACC,YAAD,CAAtB,EAAsC;MACpC;IACD;IAED,IAAMC,EAAE,GAAG,CAAAQ,QAAQ,QAAR,YAAAA,QAAQ,CAAEP,OAAV,KAAqBF,YAAY,CAACE,OAA7C;IAEA,IAAID,EAAJ,EAAQ;MACNN,KAAK,CAACM,EAAD,EAAK;QAAES,QAAQ,EAAE;MAAZ,CAAL,CAAL;IACD;EACF,CAZc,EAYZ,CAACJ,WAAD,EAAcN,YAAd,EAA4BS,QAA5B,CAZY,CAAf;AAaD"},"metadata":{},"sourceType":"module"}