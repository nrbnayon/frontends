{"ast":null,"code":"import { __spreadArray, __read } from 'tslib';\nimport { invariant } from 'hey-listen';\nimport { stopAnimation, animateVisualElement } from '../render/utils/animation.js';\nimport { setValues } from '../render/utils/setters.js';\n/**\r\n * @public\r\n */\n\nfunction animationControls() {\n  /**\r\n   * Track whether the host component has mounted.\r\n   */\n  var hasMounted = false;\n  /**\r\n   * Pending animations that are started before a component is mounted.\r\n   * TODO: Remove this as animations should only run in effects\r\n   */\n\n  var pendingAnimations = [];\n  /**\r\n   * A collection of linked component animation controls.\r\n   */\n\n  var subscribers = new Set();\n  var controls = {\n    subscribe: function subscribe(visualElement) {\n      subscribers.add(visualElement);\n      return function () {\n        return void subscribers.delete(visualElement);\n      };\n    },\n    start: function start(definition, transitionOverride) {\n      /**\r\n       * TODO: We only perform this hasMounted check because in Framer we used to\r\n       * encourage the ability to start an animation within the render phase. This\r\n       * isn't behaviour concurrent-safe so when we make Framer concurrent-safe\r\n       * we can ditch this.\r\n       */\n      if (hasMounted) {\n        var animations_1 = [];\n        subscribers.forEach(function (visualElement) {\n          animations_1.push(animateVisualElement(visualElement, definition, {\n            transitionOverride: transitionOverride\n          }));\n        });\n        return Promise.all(animations_1);\n      } else {\n        return new Promise(function (resolve) {\n          pendingAnimations.push({\n            animation: [definition, transitionOverride],\n            resolve: resolve\n          });\n        });\n      }\n    },\n    set: function set(definition) {\n      invariant(hasMounted, \"controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook.\");\n      return subscribers.forEach(function (visualElement) {\n        setValues(visualElement, definition);\n      });\n    },\n    stop: function stop() {\n      subscribers.forEach(function (visualElement) {\n        stopAnimation(visualElement);\n      });\n    },\n    mount: function mount() {\n      hasMounted = true;\n      pendingAnimations.forEach(function (_a) {\n        var animation = _a.animation,\n            resolve = _a.resolve;\n        controls.start.apply(controls, __spreadArray([], __read(animation))).then(resolve);\n      });\n      return function () {\n        hasMounted = false;\n        controls.stop();\n      };\n    }\n  };\n  return controls;\n}\n\nexport { animationControls };","map":{"version":3,"sources":["E:/Hasan sir project/ChattersTwo/frontend/node_modules/framer-motion/dist/es/animation/animation-controls.js"],"names":["__spreadArray","__read","invariant","stopAnimation","animateVisualElement","setValues","animationControls","hasMounted","pendingAnimations","subscribers","Set","controls","subscribe","visualElement","add","delete","start","definition","transitionOverride","animations_1","forEach","push","Promise","all","resolve","animation","set","stop","mount","_a","apply","then"],"mappings":"AAAA,SAASA,aAAT,EAAwBC,MAAxB,QAAsC,OAAtC;AACA,SAASC,SAAT,QAA0B,YAA1B;AACA,SAASC,aAAT,EAAwBC,oBAAxB,QAAoD,8BAApD;AACA,SAASC,SAAT,QAA0B,4BAA1B;AAEA;AACA;AACA;;AACA,SAASC,iBAAT,GAA6B;AACzB;AACJ;AACA;AACI,MAAIC,UAAU,GAAG,KAAjB;AACA;AACJ;AACA;AACA;;AACI,MAAIC,iBAAiB,GAAG,EAAxB;AACA;AACJ;AACA;;AACI,MAAIC,WAAW,GAAG,IAAIC,GAAJ,EAAlB;AACA,MAAIC,QAAQ,GAAG;AACXC,IAAAA,SAAS,EAAE,mBAAUC,aAAV,EAAyB;AAChCJ,MAAAA,WAAW,CAACK,GAAZ,CAAgBD,aAAhB;AACA,aAAO,YAAY;AAAE,eAAO,KAAKJ,WAAW,CAACM,MAAZ,CAAmBF,aAAnB,CAAZ;AAAgD,OAArE;AACH,KAJU;AAKXG,IAAAA,KAAK,EAAE,eAAUC,UAAV,EAAsBC,kBAAtB,EAA0C;AAC7C;AACZ;AACA;AACA;AACA;AACA;AACY,UAAIX,UAAJ,EAAgB;AACZ,YAAIY,YAAY,GAAG,EAAnB;AACAV,QAAAA,WAAW,CAACW,OAAZ,CAAoB,UAAUP,aAAV,EAAyB;AACzCM,UAAAA,YAAY,CAACE,IAAb,CAAkBjB,oBAAoB,CAACS,aAAD,EAAgBI,UAAhB,EAA4B;AAC9DC,YAAAA,kBAAkB,EAAEA;AAD0C,WAA5B,CAAtC;AAGH,SAJD;AAKA,eAAOI,OAAO,CAACC,GAAR,CAAYJ,YAAZ,CAAP;AACH,OARD,MASK;AACD,eAAO,IAAIG,OAAJ,CAAY,UAAUE,OAAV,EAAmB;AAClChB,UAAAA,iBAAiB,CAACa,IAAlB,CAAuB;AACnBI,YAAAA,SAAS,EAAE,CAACR,UAAD,EAAaC,kBAAb,CADQ;AAEnBM,YAAAA,OAAO,EAAEA;AAFU,WAAvB;AAIH,SALM,CAAP;AAMH;AACJ,KA7BU;AA8BXE,IAAAA,GAAG,EAAE,aAAUT,UAAV,EAAsB;AACvBf,MAAAA,SAAS,CAACK,UAAD,EAAa,+GAAb,CAAT;AACA,aAAOE,WAAW,CAACW,OAAZ,CAAoB,UAAUP,aAAV,EAAyB;AAChDR,QAAAA,SAAS,CAACQ,aAAD,EAAgBI,UAAhB,CAAT;AACH,OAFM,CAAP;AAGH,KAnCU;AAoCXU,IAAAA,IAAI,EAAE,gBAAY;AACdlB,MAAAA,WAAW,CAACW,OAAZ,CAAoB,UAAUP,aAAV,EAAyB;AACzCV,QAAAA,aAAa,CAACU,aAAD,CAAb;AACH,OAFD;AAGH,KAxCU;AAyCXe,IAAAA,KAAK,EAAE,iBAAY;AACfrB,MAAAA,UAAU,GAAG,IAAb;AACAC,MAAAA,iBAAiB,CAACY,OAAlB,CAA0B,UAAUS,EAAV,EAAc;AACpC,YAAIJ,SAAS,GAAGI,EAAE,CAACJ,SAAnB;AAAA,YAA8BD,OAAO,GAAGK,EAAE,CAACL,OAA3C;AACAb,QAAAA,QAAQ,CAACK,KAAT,CAAec,KAAf,CAAqBnB,QAArB,EAA+BX,aAAa,CAAC,EAAD,EAAKC,MAAM,CAACwB,SAAD,CAAX,CAA5C,EAAqEM,IAArE,CAA0EP,OAA1E;AACH,OAHD;AAIA,aAAO,YAAY;AACfjB,QAAAA,UAAU,GAAG,KAAb;AACAI,QAAAA,QAAQ,CAACgB,IAAT;AACH,OAHD;AAIH;AAnDU,GAAf;AAqDA,SAAOhB,QAAP;AACH;;AAED,SAASL,iBAAT","sourcesContent":["import { __spreadArray, __read } from 'tslib';\r\nimport { invariant } from 'hey-listen';\r\nimport { stopAnimation, animateVisualElement } from '../render/utils/animation.js';\r\nimport { setValues } from '../render/utils/setters.js';\r\n\r\n/**\r\n * @public\r\n */\r\nfunction animationControls() {\r\n    /**\r\n     * Track whether the host component has mounted.\r\n     */\r\n    var hasMounted = false;\r\n    /**\r\n     * Pending animations that are started before a component is mounted.\r\n     * TODO: Remove this as animations should only run in effects\r\n     */\r\n    var pendingAnimations = [];\r\n    /**\r\n     * A collection of linked component animation controls.\r\n     */\r\n    var subscribers = new Set();\r\n    var controls = {\r\n        subscribe: function (visualElement) {\r\n            subscribers.add(visualElement);\r\n            return function () { return void subscribers.delete(visualElement); };\r\n        },\r\n        start: function (definition, transitionOverride) {\r\n            /**\r\n             * TODO: We only perform this hasMounted check because in Framer we used to\r\n             * encourage the ability to start an animation within the render phase. This\r\n             * isn't behaviour concurrent-safe so when we make Framer concurrent-safe\r\n             * we can ditch this.\r\n             */\r\n            if (hasMounted) {\r\n                var animations_1 = [];\r\n                subscribers.forEach(function (visualElement) {\r\n                    animations_1.push(animateVisualElement(visualElement, definition, {\r\n                        transitionOverride: transitionOverride,\r\n                    }));\r\n                });\r\n                return Promise.all(animations_1);\r\n            }\r\n            else {\r\n                return new Promise(function (resolve) {\r\n                    pendingAnimations.push({\r\n                        animation: [definition, transitionOverride],\r\n                        resolve: resolve,\r\n                    });\r\n                });\r\n            }\r\n        },\r\n        set: function (definition) {\r\n            invariant(hasMounted, \"controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook.\");\r\n            return subscribers.forEach(function (visualElement) {\r\n                setValues(visualElement, definition);\r\n            });\r\n        },\r\n        stop: function () {\r\n            subscribers.forEach(function (visualElement) {\r\n                stopAnimation(visualElement);\r\n            });\r\n        },\r\n        mount: function () {\r\n            hasMounted = true;\r\n            pendingAnimations.forEach(function (_a) {\r\n                var animation = _a.animation, resolve = _a.resolve;\r\n                controls.start.apply(controls, __spreadArray([], __read(animation))).then(resolve);\r\n            });\r\n            return function () {\r\n                hasMounted = false;\r\n                controls.stop();\r\n            };\r\n        },\r\n    };\r\n    return controls;\r\n}\r\n\r\nexport { animationControls };\r\n"]},"metadata":{},"sourceType":"module"}