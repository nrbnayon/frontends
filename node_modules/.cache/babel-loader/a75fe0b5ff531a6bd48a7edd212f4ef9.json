{"ast":null,"code":"import { __assign, __spreadArray, __read } from 'tslib';\nimport sync, { cancelSync } from 'framesync';\nimport { pipe } from 'popmotion';\nimport { Presence } from '../components/AnimateSharedLayout/types.js';\nimport { eachAxis } from '../utils/each-axis.js';\nimport { axisBox } from '../utils/geometry/index.js';\nimport { removeBoxTransforms, applyBoxTransforms } from '../utils/geometry/delta-apply.js';\nimport { calcRelativeBox, updateBoxDelta } from '../utils/geometry/delta-calc.js';\nimport { motionValue } from '../value/index.js';\nimport { isMotionValue } from '../value/utils/is-motion-value.js';\nimport { buildLayoutProjectionTransform } from './html/utils/build-projection-transform.js';\nimport { variantPriorityOrder } from './utils/animation-state.js';\nimport { createLifecycles } from './utils/lifecycles.js';\nimport { updateMotionValuesFromProps } from './utils/motion-values.js';\nimport { updateLayoutDeltas } from './utils/projection.js';\nimport { createLayoutState, createProjectionState } from './utils/state.js';\nimport { FlatTree } from './utils/flat-tree.js';\nimport { checkIfControllingVariants, checkIfVariantNode, isVariantLabel } from './utils/variants.js';\nimport { setCurrentViewportBox } from './dom/projection/relative-set.js';\nimport { isDraggable } from './utils/is-draggable.js';\nvar visualElement = function (_a) {\n  var _b = _a.treeType,\n    treeType = _b === void 0 ? \"\" : _b,\n    build = _a.build,\n    getBaseTarget = _a.getBaseTarget,\n    makeTargetAnimatable = _a.makeTargetAnimatable,\n    measureViewportBox = _a.measureViewportBox,\n    renderInstance = _a.render,\n    readValueFromInstance = _a.readValueFromInstance,\n    resetTransform = _a.resetTransform,\n    restoreTransform = _a.restoreTransform,\n    removeValueFromRenderState = _a.removeValueFromRenderState,\n    sortNodePosition = _a.sortNodePosition,\n    scrapeMotionValuesFromProps = _a.scrapeMotionValuesFromProps;\n  return function (_a, options) {\n    var parent = _a.parent,\n      props = _a.props,\n      presenceId = _a.presenceId,\n      blockInitialAnimation = _a.blockInitialAnimation,\n      visualState = _a.visualState;\n    if (options === void 0) {\n      options = {};\n    }\n    var latestValues = visualState.latestValues,\n      renderState = visualState.renderState;\n    /**\r\n     * The instance of the render-specific node that will be hydrated by the\r\n     * exposed React ref. So for example, this visual element can host a\r\n     * HTMLElement, plain object, or Three.js object. The functions provided\r\n     * in VisualElementConfig allow us to interface with this instance.\r\n     */\n    var instance;\n    /**\r\n     * Manages the subscriptions for a visual element's lifecycle, for instance\r\n     * onRender and onViewportBoxUpdate.\r\n     */\n    var lifecycles = createLifecycles();\n    /**\r\n     *\r\n     */\n    var projection = createProjectionState();\n    /**\r\n     * A reference to the nearest projecting parent. This is either\r\n     * undefined if we haven't looked for the nearest projecting parent,\r\n     * false if there is no parent performing layout projection, or a reference\r\n     * to the projecting parent.\r\n     */\n    var projectionParent;\n    /**\r\n     * This is a reference to the visual state of the \"lead\" visual element.\r\n     * Usually, this will be this visual element. But if it shares a layoutId\r\n     * with other visual elements, only one of them will be designated lead by\r\n     * AnimateSharedLayout. All the other visual elements will take on the visual\r\n     * appearance of the lead while they crossfade to it.\r\n     */\n    var leadProjection = projection;\n    var leadLatestValues = latestValues;\n    var unsubscribeFromLeadVisualElement;\n    /**\r\n     * The latest layout measurements and calculated projections. This\r\n     * is seperate from the target projection data in visualState as\r\n     * many visual elements might point to the same piece of visualState as\r\n     * a target, whereas they might each have different layouts and thus\r\n     * projection calculations needed to project into the same viewport box.\r\n     */\n    var layoutState = createLayoutState();\n    /**\r\n     *\r\n     */\n    var crossfader;\n    /**\r\n     * Keep track of whether the viewport box has been updated since the\r\n     * last time the layout projection was re-calculated.\r\n     */\n    var hasViewportBoxUpdated = false;\n    /**\r\n     * A map of all motion values attached to this visual element. Motion\r\n     * values are source of truth for any given animated value. A motion\r\n     * value might be provided externally by the component via props.\r\n     */\n    var values = new Map();\n    /**\r\n     * A map of every subscription that binds the provided or generated\r\n     * motion values onChange listeners to this visual element.\r\n     */\n    var valueSubscriptions = new Map();\n    /**\r\n     * A reference to the previously-provided motion values as returned\r\n     * from scrapeMotionValuesFromProps. We use the keys in here to determine\r\n     * if any motion values need to be removed after props are updated.\r\n     */\n    var prevMotionValues = {};\n    /**\r\n     * x/y motion values that track the progress of initiated layout\r\n     * animations.\r\n     *\r\n     * TODO: Target for removal\r\n     */\n    var projectionTargetProgress;\n    /**\r\n     * When values are removed from all animation props we need to search\r\n     * for a fallback value to animate to. These values are tracked in baseTarget.\r\n     */\n    var baseTarget = __assign({}, latestValues);\n    // Internal methods ========================\n    /**\r\n     * On mount, this will be hydrated with a callback to disconnect\r\n     * this visual element from its parent on unmount.\r\n     */\n    var removeFromVariantTree;\n    /**\r\n     *\r\n     */\n    function render() {\n      if (!instance) return;\n      if (element.isProjectionReady()) {\n        /**\r\n         * Apply the latest user-set transforms to the targetBox to produce the targetBoxFinal.\r\n         * This is the final box that we will then project into by calculating a transform delta and\r\n         * applying it to the corrected box.\r\n         */\n        applyBoxTransforms(leadProjection.targetFinal, leadProjection.target, leadLatestValues);\n        /**\r\n         * Update the delta between the corrected box and the final target box, after\r\n         * user-set transforms are applied to it. This will be used by the renderer to\r\n         * create a transform style that will reproject the element from its actual layout\r\n         * into the desired bounding box.\r\n         */\n        updateBoxDelta(layoutState.deltaFinal, layoutState.layoutCorrected, leadProjection.targetFinal, latestValues);\n      }\n      triggerBuild();\n      renderInstance(instance, renderState);\n    }\n    function triggerBuild() {\n      var valuesToRender = latestValues;\n      if (crossfader && crossfader.isActive()) {\n        var crossfadedValues = crossfader.getCrossfadeState(element);\n        if (crossfadedValues) valuesToRender = crossfadedValues;\n      }\n      build(element, renderState, valuesToRender, leadProjection, layoutState, options, props);\n    }\n    function update() {\n      lifecycles.notifyUpdate(latestValues);\n    }\n    function updateLayoutProjection() {\n      if (!element.isProjectionReady()) return;\n      var delta = layoutState.delta,\n        treeScale = layoutState.treeScale;\n      var prevTreeScaleX = treeScale.x;\n      var prevTreeScaleY = treeScale.y;\n      var prevDeltaTransform = layoutState.deltaTransform;\n      updateLayoutDeltas(layoutState, leadProjection, element.path, latestValues);\n      hasViewportBoxUpdated && element.notifyViewportBoxUpdate(leadProjection.target, delta);\n      hasViewportBoxUpdated = false;\n      var deltaTransform = buildLayoutProjectionTransform(delta, treeScale);\n      if (deltaTransform !== prevDeltaTransform ||\n      // Also compare calculated treeScale, for values that rely on this only for scale correction\n      prevTreeScaleX !== treeScale.x || prevTreeScaleY !== treeScale.y) {\n        element.scheduleRender();\n      }\n      layoutState.deltaTransform = deltaTransform;\n    }\n    function updateTreeLayoutProjection() {\n      element.layoutTree.forEach(fireUpdateLayoutProjection);\n    }\n    /**\r\n     *\r\n     */\n    function bindToMotionValue(key, value) {\n      var removeOnChange = value.onChange(function (latestValue) {\n        latestValues[key] = latestValue;\n        props.onUpdate && sync.update(update, false, true);\n      });\n      var removeOnRenderRequest = value.onRenderRequest(element.scheduleRender);\n      valueSubscriptions.set(key, function () {\n        removeOnChange();\n        removeOnRenderRequest();\n      });\n    }\n    /**\r\n     * Any motion values that are provided to the element when created\r\n     * aren't yet bound to the element, as this would technically be impure.\r\n     * However, we iterate through the motion values and set them to the\r\n     * initial values for this component.\r\n     *\r\n     * TODO: This is impure and we should look at changing this to run on mount.\r\n     * Doing so will break some tests but this isn't neccessarily a breaking change,\r\n     * more a reflection of the test.\r\n     */\n    var initialMotionValues = scrapeMotionValuesFromProps(props);\n    for (var key in initialMotionValues) {\n      var value = initialMotionValues[key];\n      if (latestValues[key] !== undefined && isMotionValue(value)) {\n        value.set(latestValues[key], false);\n      }\n    }\n    /**\r\n     * Determine what role this visual element should take in the variant tree.\r\n     */\n    var isControllingVariants = checkIfControllingVariants(props);\n    var isVariantNode = checkIfVariantNode(props);\n    var element = __assign(__assign({\n      treeType: treeType,\n      /**\r\n       * This is a mirror of the internal instance prop, which keeps\r\n       * VisualElement type-compatible with React's RefObject.\r\n       */\n      current: null,\n      /**\r\n       * The depth of this visual element within the visual element tree.\r\n       */\n      depth: parent ? parent.depth + 1 : 0,\n      parent: parent,\n      children: new Set(),\n      /**\r\n       * An ancestor path back to the root visual element. This is used\r\n       * by layout projection to quickly recurse back up the tree.\r\n       */\n      path: parent ? __spreadArray(__spreadArray([], __read(parent.path)), [parent]) : [],\n      layoutTree: parent ? parent.layoutTree : new FlatTree(),\n      /**\r\n       *\r\n       */\n      presenceId: presenceId,\n      projection: projection,\n      /**\r\n       * If this component is part of the variant tree, it should track\r\n       * any children that are also part of the tree. This is essentially\r\n       * a shadow tree to simplify logic around how to stagger over children.\r\n       */\n      variantChildren: isVariantNode ? new Set() : undefined,\n      /**\r\n       * Whether this instance is visible. This can be changed imperatively\r\n       * by AnimateSharedLayout, is analogous to CSS's visibility in that\r\n       * hidden elements should take up layout, and needs enacting by the configured\r\n       * render function.\r\n       */\n      isVisible: undefined,\n      /**\r\n       * Normally, if a component is controlled by a parent's variants, it can\r\n       * rely on that ancestor to trigger animations further down the tree.\r\n       * However, if a component is created after its parent is mounted, the parent\r\n       * won't trigger that mount animation so the child needs to.\r\n       *\r\n       * TODO: This might be better replaced with a method isParentMounted\r\n       */\n      manuallyAnimateOnMount: Boolean(parent === null || parent === void 0 ? void 0 : parent.isMounted()),\n      /**\r\n       * This can be set by AnimatePresence to force components that mount\r\n       * at the same time as it to mount as if they have initial={false} set.\r\n       */\n      blockInitialAnimation: blockInitialAnimation,\n      /**\r\n       * Determine whether this component has mounted yet. This is mostly used\r\n       * by variant children to determine whether they need to trigger their\r\n       * own animations on mount.\r\n       */\n      isMounted: function () {\n        return Boolean(instance);\n      },\n      mount: function (newInstance) {\n        instance = element.current = newInstance;\n        element.pointTo(element);\n        if (isVariantNode && parent && !isControllingVariants) {\n          removeFromVariantTree = parent === null || parent === void 0 ? void 0 : parent.addVariantChild(element);\n        }\n        parent === null || parent === void 0 ? void 0 : parent.children.add(element);\n      },\n      /**\r\n       *\r\n       */\n      unmount: function () {\n        cancelSync.update(update);\n        cancelSync.render(render);\n        cancelSync.preRender(element.updateLayoutProjection);\n        valueSubscriptions.forEach(function (remove) {\n          return remove();\n        });\n        element.stopLayoutAnimation();\n        element.layoutTree.remove(element);\n        removeFromVariantTree === null || removeFromVariantTree === void 0 ? void 0 : removeFromVariantTree();\n        parent === null || parent === void 0 ? void 0 : parent.children.delete(element);\n        unsubscribeFromLeadVisualElement === null || unsubscribeFromLeadVisualElement === void 0 ? void 0 : unsubscribeFromLeadVisualElement();\n        lifecycles.clearAllListeners();\n      },\n      /**\r\n       * Add a child visual element to our set of children.\r\n       */\n      addVariantChild: function (child) {\n        var _a;\n        var closestVariantNode = element.getClosestVariantNode();\n        if (closestVariantNode) {\n          (_a = closestVariantNode.variantChildren) === null || _a === void 0 ? void 0 : _a.add(child);\n          return function () {\n            return closestVariantNode.variantChildren.delete(child);\n          };\n        }\n      },\n      sortNodePosition: function (other) {\n        /**\r\n         * If these nodes aren't even of the same type we can't compare their depth.\r\n         */\n        if (!sortNodePosition || treeType !== other.treeType) return 0;\n        return sortNodePosition(element.getInstance(), other.getInstance());\n      },\n      /**\r\n       * Returns the closest variant node in the tree starting from\r\n       * this visual element.\r\n       */\n      getClosestVariantNode: function () {\n        return isVariantNode ? element : parent === null || parent === void 0 ? void 0 : parent.getClosestVariantNode();\n      },\n      /**\r\n       * A method that schedules an update to layout projections throughout\r\n       * the tree. We inherit from the parent so there's only ever one\r\n       * job scheduled on the next frame - that of the root visual element.\r\n       */\n      scheduleUpdateLayoutProjection: parent ? parent.scheduleUpdateLayoutProjection : function () {\n        return sync.preRender(element.updateTreeLayoutProjection, false, true);\n      },\n      /**\r\n       * Expose the latest layoutId prop.\r\n       */\n      getLayoutId: function () {\n        return props.layoutId;\n      },\n      /**\r\n       * Returns the current instance.\r\n       */\n      getInstance: function () {\n        return instance;\n      },\n      /**\r\n       * Get/set the latest static values.\r\n       */\n      getStaticValue: function (key) {\n        return latestValues[key];\n      },\n      setStaticValue: function (key, value) {\n        return latestValues[key] = value;\n      },\n      /**\r\n       * Returns the latest motion value state. Currently only used to take\r\n       * a snapshot of the visual element - perhaps this can return the whole\r\n       * visual state\r\n       */\n      getLatestValues: function () {\n        return latestValues;\n      },\n      /**\r\n       * Set the visiblity of the visual element. If it's changed, schedule\r\n       * a render to reflect these changes.\r\n       */\n      setVisibility: function (visibility) {\n        if (element.isVisible === visibility) return;\n        element.isVisible = visibility;\n        element.scheduleRender();\n      },\n      /**\r\n       * Make a target animatable by Popmotion. For instance, if we're\r\n       * trying to animate width from 100px to 100vw we need to measure 100vw\r\n       * in pixels to determine what we really need to animate to. This is also\r\n       * pluggable to support Framer's custom value types like Color,\r\n       * and CSS variables.\r\n       */\n      makeTargetAnimatable: function (target, canMutate) {\n        if (canMutate === void 0) {\n          canMutate = true;\n        }\n        return makeTargetAnimatable(element, target, props, canMutate);\n      },\n      // Motion values ========================\n      /**\r\n       * Add a motion value and bind it to this visual element.\r\n       */\n      addValue: function (key, value) {\n        // Remove existing value if it exists\n        if (element.hasValue(key)) element.removeValue(key);\n        values.set(key, value);\n        latestValues[key] = value.get();\n        bindToMotionValue(key, value);\n      },\n      /**\r\n       * Remove a motion value and unbind any active subscriptions.\r\n       */\n      removeValue: function (key) {\n        var _a;\n        values.delete(key);\n        (_a = valueSubscriptions.get(key)) === null || _a === void 0 ? void 0 : _a();\n        valueSubscriptions.delete(key);\n        delete latestValues[key];\n        removeValueFromRenderState(key, renderState);\n      },\n      /**\r\n       * Check whether we have a motion value for this key\r\n       */\n      hasValue: function (key) {\n        return values.has(key);\n      },\n      /**\r\n       * Get a motion value for this key. If called with a default\r\n       * value, we'll create one if none exists.\r\n       */\n      getValue: function (key, defaultValue) {\n        var value = values.get(key);\n        if (value === undefined && defaultValue !== undefined) {\n          value = motionValue(defaultValue);\n          element.addValue(key, value);\n        }\n        return value;\n      },\n      /**\r\n       * Iterate over our motion values.\r\n       */\n      forEachValue: function (callback) {\n        return values.forEach(callback);\n      },\n      /**\r\n       * If we're trying to animate to a previously unencountered value,\r\n       * we need to check for it in our state and as a last resort read it\r\n       * directly from the instance (which might have performance implications).\r\n       */\n      readValue: function (key) {\n        var _a;\n        return (_a = latestValues[key]) !== null && _a !== void 0 ? _a : readValueFromInstance(instance, key, options);\n      },\n      /**\r\n       * Set the base target to later animate back to. This is currently\r\n       * only hydrated on creation and when we first read a value.\r\n       */\n      setBaseTarget: function (key, value) {\n        baseTarget[key] = value;\n      },\n      /**\r\n       * Find the base target for a value thats been removed from all animation\r\n       * props.\r\n       */\n      getBaseTarget: function (key) {\n        if (getBaseTarget) {\n          var target = getBaseTarget(props, key);\n          if (target !== undefined && !isMotionValue(target)) return target;\n        }\n        return baseTarget[key];\n      }\n    }, lifecycles), {\n      /**\r\n       * Build the renderer state based on the latest visual state.\r\n       */\n      build: function () {\n        triggerBuild();\n        return renderState;\n      },\n      /**\r\n       * Schedule a render on the next animation frame.\r\n       */\n      scheduleRender: function () {\n        sync.render(render, false, true);\n      },\n      /**\r\n       * Synchronously fire render. It's prefered that we batch renders but\r\n       * in many circumstances, like layout measurement, we need to run this\r\n       * synchronously. However in those instances other measures should be taken\r\n       * to batch reads/writes.\r\n       */\n      syncRender: render,\n      /**\r\n       * Update the provided props. Ensure any newly-added motion values are\r\n       * added to our map, old ones removed, and listeners updated.\r\n       */\n      setProps: function (newProps) {\n        props = newProps;\n        lifecycles.updatePropListeners(newProps);\n        prevMotionValues = updateMotionValuesFromProps(element, scrapeMotionValuesFromProps(props), prevMotionValues);\n      },\n      getProps: function () {\n        return props;\n      },\n      // Variants ==============================\n      /**\r\n       * Returns the variant definition with a given name.\r\n       */\n      getVariant: function (name) {\n        var _a;\n        return (_a = props.variants) === null || _a === void 0 ? void 0 : _a[name];\n      },\n      /**\r\n       * Returns the defined default transition on this component.\r\n       */\n      getDefaultTransition: function () {\n        return props.transition;\n      },\n      /**\r\n       * Used by child variant nodes to get the closest ancestor variant props.\r\n       */\n      getVariantContext: function (startAtParent) {\n        if (startAtParent === void 0) {\n          startAtParent = false;\n        }\n        if (startAtParent) return parent === null || parent === void 0 ? void 0 : parent.getVariantContext();\n        if (!isControllingVariants) {\n          var context_1 = (parent === null || parent === void 0 ? void 0 : parent.getVariantContext()) || {};\n          if (props.initial !== undefined) {\n            context_1.initial = props.initial;\n          }\n          return context_1;\n        }\n        var context = {};\n        for (var i = 0; i < numVariantProps; i++) {\n          var name_1 = variantProps[i];\n          var prop = props[name_1];\n          if (isVariantLabel(prop) || prop === false) {\n            context[name_1] = prop;\n          }\n        }\n        return context;\n      },\n      // Layout projection ==============================\n      /**\r\n       * Enable layout projection for this visual element. Won't actually\r\n       * occur until we also have hydrated layout measurements.\r\n       */\n      enableLayoutProjection: function () {\n        projection.isEnabled = true;\n        element.layoutTree.add(element);\n      },\n      /**\r\n       * Lock the projection target, for instance when dragging, so\r\n       * nothing else can try and animate it.\r\n       */\n      lockProjectionTarget: function () {\n        projection.isTargetLocked = true;\n      },\n      unlockProjectionTarget: function () {\n        element.stopLayoutAnimation();\n        projection.isTargetLocked = false;\n      },\n      getLayoutState: function () {\n        return layoutState;\n      },\n      setCrossfader: function (newCrossfader) {\n        crossfader = newCrossfader;\n      },\n      isProjectionReady: function () {\n        return projection.isEnabled && projection.isHydrated && layoutState.isHydrated;\n      },\n      /**\r\n       * Start a layout animation on a given axis.\r\n       */\n      startLayoutAnimation: function (axis, transition, isRelative) {\n        if (isRelative === void 0) {\n          isRelative = false;\n        }\n        var progress = element.getProjectionAnimationProgress()[axis];\n        var _a = isRelative ? projection.relativeTarget[axis] : projection.target[axis],\n          min = _a.min,\n          max = _a.max;\n        var length = max - min;\n        progress.clearListeners();\n        progress.set(min);\n        progress.set(min); // Set twice to hard-reset velocity\n        progress.onChange(function (v) {\n          element.setProjectionTargetAxis(axis, v, v + length, isRelative);\n        });\n        return element.animateMotionValue(axis, progress, 0, transition);\n      },\n      /**\r\n       * Stop layout animations.\r\n       */\n      stopLayoutAnimation: function () {\n        eachAxis(function (axis) {\n          return element.getProjectionAnimationProgress()[axis].stop();\n        });\n      },\n      /**\r\n       * Measure the current viewport box with or without transforms.\r\n       * Only measures axis-aligned boxes, rotate and skew must be manually\r\n       * removed with a re-render to work.\r\n       */\n      measureViewportBox: function (withTransform) {\n        if (withTransform === void 0) {\n          withTransform = true;\n        }\n        var viewportBox = measureViewportBox(instance, options);\n        if (!withTransform) removeBoxTransforms(viewportBox, latestValues);\n        return viewportBox;\n      },\n      /**\r\n       * Get the motion values tracking the layout animations on each\r\n       * axis. Lazy init if not already created.\r\n       */\n      getProjectionAnimationProgress: function () {\n        projectionTargetProgress || (projectionTargetProgress = {\n          x: motionValue(0),\n          y: motionValue(0)\n        });\n        return projectionTargetProgress;\n      },\n      /**\r\n       * Update the projection of a single axis. Schedule an update to\r\n       * the tree layout projection.\r\n       */\n      setProjectionTargetAxis: function (axis, min, max, isRelative) {\n        if (isRelative === void 0) {\n          isRelative = false;\n        }\n        var target;\n        if (isRelative) {\n          if (!projection.relativeTarget) {\n            projection.relativeTarget = axisBox();\n          }\n          target = projection.relativeTarget[axis];\n        } else {\n          projection.relativeTarget = undefined;\n          target = projection.target[axis];\n        }\n        projection.isHydrated = true;\n        target.min = min;\n        target.max = max;\n        // Flag that we want to fire the onViewportBoxUpdate event handler\n        hasViewportBoxUpdated = true;\n        lifecycles.notifySetAxisTarget();\n      },\n      /**\r\n       * Rebase the projection target on top of the provided viewport box\r\n       * or the measured layout. This ensures that non-animating elements\r\n       * don't fall out of sync differences in measurements vs projections\r\n       * after a page scroll or other relayout.\r\n       */\n      rebaseProjectionTarget: function (force, box) {\n        if (box === void 0) {\n          box = layoutState.layout;\n        }\n        var _a = element.getProjectionAnimationProgress(),\n          x = _a.x,\n          y = _a.y;\n        var shouldRebase = !projection.relativeTarget && !projection.isTargetLocked && !x.isAnimating() && !y.isAnimating();\n        if (force || shouldRebase) {\n          eachAxis(function (axis) {\n            var _a = box[axis],\n              min = _a.min,\n              max = _a.max;\n            element.setProjectionTargetAxis(axis, min, max);\n          });\n        }\n      },\n      /**\r\n       * Notify the visual element that its layout is up-to-date.\r\n       * Currently Animate.tsx uses this to check whether a layout animation\r\n       * needs to be performed.\r\n       */\n      notifyLayoutReady: function (config) {\n        setCurrentViewportBox(element);\n        element.notifyLayoutUpdate(layoutState.layout, element.prevViewportBox || layoutState.layout, config);\n      },\n      /**\r\n       * Temporarily reset the transform of the instance.\r\n       */\n      resetTransform: function () {\n        return resetTransform(element, instance, props);\n      },\n      restoreTransform: function () {\n        return restoreTransform(instance, renderState);\n      },\n      updateLayoutProjection: updateLayoutProjection,\n      updateTreeLayoutProjection: function () {\n        element.layoutTree.forEach(fireResolveRelativeTargetBox);\n        /**\r\n         * Schedule the projection updates at the end of the current preRender\r\n         * step. This will ensure that all layout trees will first resolve\r\n         * relative projection boxes into viewport boxes, and *then*\r\n         * update projections.\r\n         */\n        sync.preRender(updateTreeLayoutProjection, false, true);\n        // sync.postRender(() => element.scheduleUpdateLayoutProjection())\n      },\n      getProjectionParent: function () {\n        if (projectionParent === undefined) {\n          var foundParent = false;\n          // Search backwards through the tree path\n          for (var i = element.path.length - 1; i >= 0; i--) {\n            var ancestor = element.path[i];\n            if (ancestor.projection.isEnabled) {\n              foundParent = ancestor;\n              break;\n            }\n          }\n          projectionParent = foundParent;\n        }\n        return projectionParent;\n      },\n      resolveRelativeTargetBox: function () {\n        var relativeParent = element.getProjectionParent();\n        if (!projection.relativeTarget || !relativeParent) return;\n        calcRelativeBox(projection, relativeParent.projection);\n        if (isDraggable(relativeParent)) {\n          var target = projection.target;\n          applyBoxTransforms(target, target, relativeParent.getLatestValues());\n        }\n      },\n      shouldResetTransform: function () {\n        return Boolean(props._layoutResetTransform);\n      },\n      /**\r\n       *\r\n       */\n      pointTo: function (newLead) {\n        leadProjection = newLead.projection;\n        leadLatestValues = newLead.getLatestValues();\n        /**\r\n         * Subscribe to lead component's layout animations\r\n         */\n        unsubscribeFromLeadVisualElement === null || unsubscribeFromLeadVisualElement === void 0 ? void 0 : unsubscribeFromLeadVisualElement();\n        unsubscribeFromLeadVisualElement = pipe(newLead.onSetAxisTarget(element.scheduleUpdateLayoutProjection), newLead.onLayoutAnimationComplete(function () {\n          var _a;\n          if (element.isPresent) {\n            element.presence = Presence.Present;\n          } else {\n            (_a = element.layoutSafeToRemove) === null || _a === void 0 ? void 0 : _a.call(element);\n          }\n        }));\n      },\n      // TODO: Clean this up\n      isPresent: true,\n      presence: Presence.Entering\n    });\n    return element;\n  };\n};\nfunction fireResolveRelativeTargetBox(child) {\n  child.resolveRelativeTargetBox();\n}\nfunction fireUpdateLayoutProjection(child) {\n  child.updateLayoutProjection();\n}\nvar variantProps = __spreadArray([\"initial\"], __read(variantPriorityOrder));\nvar numVariantProps = variantProps.length;\nexport { visualElement };","map":{"version":3,"names":["__assign","__spreadArray","__read","sync","cancelSync","pipe","Presence","eachAxis","axisBox","removeBoxTransforms","applyBoxTransforms","calcRelativeBox","updateBoxDelta","motionValue","isMotionValue","buildLayoutProjectionTransform","variantPriorityOrder","createLifecycles","updateMotionValuesFromProps","updateLayoutDeltas","createLayoutState","createProjectionState","FlatTree","checkIfControllingVariants","checkIfVariantNode","isVariantLabel","setCurrentViewportBox","isDraggable","visualElement","_a","_b","treeType","build","getBaseTarget","makeTargetAnimatable","measureViewportBox","renderInstance","render","readValueFromInstance","resetTransform","restoreTransform","removeValueFromRenderState","sortNodePosition","scrapeMotionValuesFromProps","options","parent","props","presenceId","blockInitialAnimation","visualState","latestValues","renderState","instance","lifecycles","projection","projectionParent","leadProjection","leadLatestValues","unsubscribeFromLeadVisualElement","layoutState","crossfader","hasViewportBoxUpdated","values","Map","valueSubscriptions","prevMotionValues","projectionTargetProgress","baseTarget","removeFromVariantTree","element","isProjectionReady","targetFinal","target","deltaFinal","layoutCorrected","triggerBuild","valuesToRender","isActive","crossfadedValues","getCrossfadeState","update","notifyUpdate","updateLayoutProjection","delta","treeScale","prevTreeScaleX","x","prevTreeScaleY","y","prevDeltaTransform","deltaTransform","path","notifyViewportBoxUpdate","scheduleRender","updateTreeLayoutProjection","layoutTree","forEach","fireUpdateLayoutProjection","bindToMotionValue","key","value","removeOnChange","onChange","latestValue","onUpdate","removeOnRenderRequest","onRenderRequest","set","initialMotionValues","undefined","isControllingVariants","isVariantNode","current","depth","children","Set","variantChildren","isVisible","manuallyAnimateOnMount","Boolean","isMounted","mount","newInstance","pointTo","addVariantChild","add","unmount","preRender","remove","stopLayoutAnimation","delete","clearAllListeners","child","closestVariantNode","getClosestVariantNode","other","getInstance","scheduleUpdateLayoutProjection","getLayoutId","layoutId","getStaticValue","setStaticValue","getLatestValues","setVisibility","visibility","canMutate","addValue","hasValue","removeValue","get","has","getValue","defaultValue","forEachValue","callback","readValue","setBaseTarget","syncRender","setProps","newProps","updatePropListeners","getProps","getVariant","name","variants","getDefaultTransition","transition","getVariantContext","startAtParent","context_1","initial","context","i","numVariantProps","name_1","variantProps","prop","enableLayoutProjection","isEnabled","lockProjectionTarget","isTargetLocked","unlockProjectionTarget","getLayoutState","setCrossfader","newCrossfader","isHydrated","startLayoutAnimation","axis","isRelative","progress","getProjectionAnimationProgress","relativeTarget","min","max","length","clearListeners","v","setProjectionTargetAxis","animateMotionValue","stop","withTransform","viewportBox","notifySetAxisTarget","rebaseProjectionTarget","force","box","layout","shouldRebase","isAnimating","notifyLayoutReady","config","notifyLayoutUpdate","prevViewportBox","fireResolveRelativeTargetBox","getProjectionParent","foundParent","ancestor","resolveRelativeTargetBox","relativeParent","shouldResetTransform","_layoutResetTransform","newLead","onSetAxisTarget","onLayoutAnimationComplete","isPresent","presence","Present","layoutSafeToRemove","call","Entering"],"sources":["E:/Hasan sir project/4/frontend/node_modules/framer-motion/dist/es/render/index.js"],"sourcesContent":["import { __assign, __spreadArray, __read } from 'tslib';\r\nimport sync, { cancelSync } from 'framesync';\r\nimport { pipe } from 'popmotion';\r\nimport { Presence } from '../components/AnimateSharedLayout/types.js';\r\nimport { eachAxis } from '../utils/each-axis.js';\r\nimport { axisBox } from '../utils/geometry/index.js';\r\nimport { removeBoxTransforms, applyBoxTransforms } from '../utils/geometry/delta-apply.js';\r\nimport { calcRelativeBox, updateBoxDelta } from '../utils/geometry/delta-calc.js';\r\nimport { motionValue } from '../value/index.js';\r\nimport { isMotionValue } from '../value/utils/is-motion-value.js';\r\nimport { buildLayoutProjectionTransform } from './html/utils/build-projection-transform.js';\r\nimport { variantPriorityOrder } from './utils/animation-state.js';\r\nimport { createLifecycles } from './utils/lifecycles.js';\r\nimport { updateMotionValuesFromProps } from './utils/motion-values.js';\r\nimport { updateLayoutDeltas } from './utils/projection.js';\r\nimport { createLayoutState, createProjectionState } from './utils/state.js';\r\nimport { FlatTree } from './utils/flat-tree.js';\r\nimport { checkIfControllingVariants, checkIfVariantNode, isVariantLabel } from './utils/variants.js';\r\nimport { setCurrentViewportBox } from './dom/projection/relative-set.js';\r\nimport { isDraggable } from './utils/is-draggable.js';\r\n\r\nvar visualElement = function (_a) {\r\n    var _b = _a.treeType, treeType = _b === void 0 ? \"\" : _b, build = _a.build, getBaseTarget = _a.getBaseTarget, makeTargetAnimatable = _a.makeTargetAnimatable, measureViewportBox = _a.measureViewportBox, renderInstance = _a.render, readValueFromInstance = _a.readValueFromInstance, resetTransform = _a.resetTransform, restoreTransform = _a.restoreTransform, removeValueFromRenderState = _a.removeValueFromRenderState, sortNodePosition = _a.sortNodePosition, scrapeMotionValuesFromProps = _a.scrapeMotionValuesFromProps;\r\n    return function (_a, options) {\r\n        var parent = _a.parent, props = _a.props, presenceId = _a.presenceId, blockInitialAnimation = _a.blockInitialAnimation, visualState = _a.visualState;\r\n        if (options === void 0) { options = {}; }\r\n        var latestValues = visualState.latestValues, renderState = visualState.renderState;\r\n        /**\r\n         * The instance of the render-specific node that will be hydrated by the\r\n         * exposed React ref. So for example, this visual element can host a\r\n         * HTMLElement, plain object, or Three.js object. The functions provided\r\n         * in VisualElementConfig allow us to interface with this instance.\r\n         */\r\n        var instance;\r\n        /**\r\n         * Manages the subscriptions for a visual element's lifecycle, for instance\r\n         * onRender and onViewportBoxUpdate.\r\n         */\r\n        var lifecycles = createLifecycles();\r\n        /**\r\n         *\r\n         */\r\n        var projection = createProjectionState();\r\n        /**\r\n         * A reference to the nearest projecting parent. This is either\r\n         * undefined if we haven't looked for the nearest projecting parent,\r\n         * false if there is no parent performing layout projection, or a reference\r\n         * to the projecting parent.\r\n         */\r\n        var projectionParent;\r\n        /**\r\n         * This is a reference to the visual state of the \"lead\" visual element.\r\n         * Usually, this will be this visual element. But if it shares a layoutId\r\n         * with other visual elements, only one of them will be designated lead by\r\n         * AnimateSharedLayout. All the other visual elements will take on the visual\r\n         * appearance of the lead while they crossfade to it.\r\n         */\r\n        var leadProjection = projection;\r\n        var leadLatestValues = latestValues;\r\n        var unsubscribeFromLeadVisualElement;\r\n        /**\r\n         * The latest layout measurements and calculated projections. This\r\n         * is seperate from the target projection data in visualState as\r\n         * many visual elements might point to the same piece of visualState as\r\n         * a target, whereas they might each have different layouts and thus\r\n         * projection calculations needed to project into the same viewport box.\r\n         */\r\n        var layoutState = createLayoutState();\r\n        /**\r\n         *\r\n         */\r\n        var crossfader;\r\n        /**\r\n         * Keep track of whether the viewport box has been updated since the\r\n         * last time the layout projection was re-calculated.\r\n         */\r\n        var hasViewportBoxUpdated = false;\r\n        /**\r\n         * A map of all motion values attached to this visual element. Motion\r\n         * values are source of truth for any given animated value. A motion\r\n         * value might be provided externally by the component via props.\r\n         */\r\n        var values = new Map();\r\n        /**\r\n         * A map of every subscription that binds the provided or generated\r\n         * motion values onChange listeners to this visual element.\r\n         */\r\n        var valueSubscriptions = new Map();\r\n        /**\r\n         * A reference to the previously-provided motion values as returned\r\n         * from scrapeMotionValuesFromProps. We use the keys in here to determine\r\n         * if any motion values need to be removed after props are updated.\r\n         */\r\n        var prevMotionValues = {};\r\n        /**\r\n         * x/y motion values that track the progress of initiated layout\r\n         * animations.\r\n         *\r\n         * TODO: Target for removal\r\n         */\r\n        var projectionTargetProgress;\r\n        /**\r\n         * When values are removed from all animation props we need to search\r\n         * for a fallback value to animate to. These values are tracked in baseTarget.\r\n         */\r\n        var baseTarget = __assign({}, latestValues);\r\n        // Internal methods ========================\r\n        /**\r\n         * On mount, this will be hydrated with a callback to disconnect\r\n         * this visual element from its parent on unmount.\r\n         */\r\n        var removeFromVariantTree;\r\n        /**\r\n         *\r\n         */\r\n        function render() {\r\n            if (!instance)\r\n                return;\r\n            if (element.isProjectionReady()) {\r\n                /**\r\n                 * Apply the latest user-set transforms to the targetBox to produce the targetBoxFinal.\r\n                 * This is the final box that we will then project into by calculating a transform delta and\r\n                 * applying it to the corrected box.\r\n                 */\r\n                applyBoxTransforms(leadProjection.targetFinal, leadProjection.target, leadLatestValues);\r\n                /**\r\n                 * Update the delta between the corrected box and the final target box, after\r\n                 * user-set transforms are applied to it. This will be used by the renderer to\r\n                 * create a transform style that will reproject the element from its actual layout\r\n                 * into the desired bounding box.\r\n                 */\r\n                updateBoxDelta(layoutState.deltaFinal, layoutState.layoutCorrected, leadProjection.targetFinal, latestValues);\r\n            }\r\n            triggerBuild();\r\n            renderInstance(instance, renderState);\r\n        }\r\n        function triggerBuild() {\r\n            var valuesToRender = latestValues;\r\n            if (crossfader && crossfader.isActive()) {\r\n                var crossfadedValues = crossfader.getCrossfadeState(element);\r\n                if (crossfadedValues)\r\n                    valuesToRender = crossfadedValues;\r\n            }\r\n            build(element, renderState, valuesToRender, leadProjection, layoutState, options, props);\r\n        }\r\n        function update() {\r\n            lifecycles.notifyUpdate(latestValues);\r\n        }\r\n        function updateLayoutProjection() {\r\n            if (!element.isProjectionReady())\r\n                return;\r\n            var delta = layoutState.delta, treeScale = layoutState.treeScale;\r\n            var prevTreeScaleX = treeScale.x;\r\n            var prevTreeScaleY = treeScale.y;\r\n            var prevDeltaTransform = layoutState.deltaTransform;\r\n            updateLayoutDeltas(layoutState, leadProjection, element.path, latestValues);\r\n            hasViewportBoxUpdated &&\r\n                element.notifyViewportBoxUpdate(leadProjection.target, delta);\r\n            hasViewportBoxUpdated = false;\r\n            var deltaTransform = buildLayoutProjectionTransform(delta, treeScale);\r\n            if (deltaTransform !== prevDeltaTransform ||\r\n                // Also compare calculated treeScale, for values that rely on this only for scale correction\r\n                prevTreeScaleX !== treeScale.x ||\r\n                prevTreeScaleY !== treeScale.y) {\r\n                element.scheduleRender();\r\n            }\r\n            layoutState.deltaTransform = deltaTransform;\r\n        }\r\n        function updateTreeLayoutProjection() {\r\n            element.layoutTree.forEach(fireUpdateLayoutProjection);\r\n        }\r\n        /**\r\n         *\r\n         */\r\n        function bindToMotionValue(key, value) {\r\n            var removeOnChange = value.onChange(function (latestValue) {\r\n                latestValues[key] = latestValue;\r\n                props.onUpdate && sync.update(update, false, true);\r\n            });\r\n            var removeOnRenderRequest = value.onRenderRequest(element.scheduleRender);\r\n            valueSubscriptions.set(key, function () {\r\n                removeOnChange();\r\n                removeOnRenderRequest();\r\n            });\r\n        }\r\n        /**\r\n         * Any motion values that are provided to the element when created\r\n         * aren't yet bound to the element, as this would technically be impure.\r\n         * However, we iterate through the motion values and set them to the\r\n         * initial values for this component.\r\n         *\r\n         * TODO: This is impure and we should look at changing this to run on mount.\r\n         * Doing so will break some tests but this isn't neccessarily a breaking change,\r\n         * more a reflection of the test.\r\n         */\r\n        var initialMotionValues = scrapeMotionValuesFromProps(props);\r\n        for (var key in initialMotionValues) {\r\n            var value = initialMotionValues[key];\r\n            if (latestValues[key] !== undefined && isMotionValue(value)) {\r\n                value.set(latestValues[key], false);\r\n            }\r\n        }\r\n        /**\r\n         * Determine what role this visual element should take in the variant tree.\r\n         */\r\n        var isControllingVariants = checkIfControllingVariants(props);\r\n        var isVariantNode = checkIfVariantNode(props);\r\n        var element = __assign(__assign({ treeType: treeType, \r\n            /**\r\n             * This is a mirror of the internal instance prop, which keeps\r\n             * VisualElement type-compatible with React's RefObject.\r\n             */\r\n            current: null, \r\n            /**\r\n             * The depth of this visual element within the visual element tree.\r\n             */\r\n            depth: parent ? parent.depth + 1 : 0, parent: parent, children: new Set(), \r\n            /**\r\n             * An ancestor path back to the root visual element. This is used\r\n             * by layout projection to quickly recurse back up the tree.\r\n             */\r\n            path: parent ? __spreadArray(__spreadArray([], __read(parent.path)), [parent]) : [], layoutTree: parent ? parent.layoutTree : new FlatTree(), \r\n            /**\r\n             *\r\n             */\r\n            presenceId: presenceId,\r\n            projection: projection, \r\n            /**\r\n             * If this component is part of the variant tree, it should track\r\n             * any children that are also part of the tree. This is essentially\r\n             * a shadow tree to simplify logic around how to stagger over children.\r\n             */\r\n            variantChildren: isVariantNode ? new Set() : undefined, \r\n            /**\r\n             * Whether this instance is visible. This can be changed imperatively\r\n             * by AnimateSharedLayout, is analogous to CSS's visibility in that\r\n             * hidden elements should take up layout, and needs enacting by the configured\r\n             * render function.\r\n             */\r\n            isVisible: undefined, \r\n            /**\r\n             * Normally, if a component is controlled by a parent's variants, it can\r\n             * rely on that ancestor to trigger animations further down the tree.\r\n             * However, if a component is created after its parent is mounted, the parent\r\n             * won't trigger that mount animation so the child needs to.\r\n             *\r\n             * TODO: This might be better replaced with a method isParentMounted\r\n             */\r\n            manuallyAnimateOnMount: Boolean(parent === null || parent === void 0 ? void 0 : parent.isMounted()), \r\n            /**\r\n             * This can be set by AnimatePresence to force components that mount\r\n             * at the same time as it to mount as if they have initial={false} set.\r\n             */\r\n            blockInitialAnimation: blockInitialAnimation, \r\n            /**\r\n             * Determine whether this component has mounted yet. This is mostly used\r\n             * by variant children to determine whether they need to trigger their\r\n             * own animations on mount.\r\n             */\r\n            isMounted: function () { return Boolean(instance); }, mount: function (newInstance) {\r\n                instance = element.current = newInstance;\r\n                element.pointTo(element);\r\n                if (isVariantNode && parent && !isControllingVariants) {\r\n                    removeFromVariantTree = parent === null || parent === void 0 ? void 0 : parent.addVariantChild(element);\r\n                }\r\n                parent === null || parent === void 0 ? void 0 : parent.children.add(element);\r\n            },\r\n            /**\r\n             *\r\n             */\r\n            unmount: function () {\r\n                cancelSync.update(update);\r\n                cancelSync.render(render);\r\n                cancelSync.preRender(element.updateLayoutProjection);\r\n                valueSubscriptions.forEach(function (remove) { return remove(); });\r\n                element.stopLayoutAnimation();\r\n                element.layoutTree.remove(element);\r\n                removeFromVariantTree === null || removeFromVariantTree === void 0 ? void 0 : removeFromVariantTree();\r\n                parent === null || parent === void 0 ? void 0 : parent.children.delete(element);\r\n                unsubscribeFromLeadVisualElement === null || unsubscribeFromLeadVisualElement === void 0 ? void 0 : unsubscribeFromLeadVisualElement();\r\n                lifecycles.clearAllListeners();\r\n            },\r\n            /**\r\n             * Add a child visual element to our set of children.\r\n             */\r\n            addVariantChild: function (child) {\r\n                var _a;\r\n                var closestVariantNode = element.getClosestVariantNode();\r\n                if (closestVariantNode) {\r\n                    (_a = closestVariantNode.variantChildren) === null || _a === void 0 ? void 0 : _a.add(child);\r\n                    return function () { return closestVariantNode.variantChildren.delete(child); };\r\n                }\r\n            },\r\n            sortNodePosition: function (other) {\r\n                /**\r\n                 * If these nodes aren't even of the same type we can't compare their depth.\r\n                 */\r\n                if (!sortNodePosition || treeType !== other.treeType)\r\n                    return 0;\r\n                return sortNodePosition(element.getInstance(), other.getInstance());\r\n            }, \r\n            /**\r\n             * Returns the closest variant node in the tree starting from\r\n             * this visual element.\r\n             */\r\n            getClosestVariantNode: function () {\r\n                return isVariantNode ? element : parent === null || parent === void 0 ? void 0 : parent.getClosestVariantNode();\r\n            }, \r\n            /**\r\n             * A method that schedules an update to layout projections throughout\r\n             * the tree. We inherit from the parent so there's only ever one\r\n             * job scheduled on the next frame - that of the root visual element.\r\n             */\r\n            scheduleUpdateLayoutProjection: parent\r\n                ? parent.scheduleUpdateLayoutProjection\r\n                : function () {\r\n                    return sync.preRender(element.updateTreeLayoutProjection, false, true);\r\n                }, \r\n            /**\r\n             * Expose the latest layoutId prop.\r\n             */\r\n            getLayoutId: function () { return props.layoutId; }, \r\n            /**\r\n             * Returns the current instance.\r\n             */\r\n            getInstance: function () { return instance; }, \r\n            /**\r\n             * Get/set the latest static values.\r\n             */\r\n            getStaticValue: function (key) { return latestValues[key]; }, setStaticValue: function (key, value) { return (latestValues[key] = value); }, \r\n            /**\r\n             * Returns the latest motion value state. Currently only used to take\r\n             * a snapshot of the visual element - perhaps this can return the whole\r\n             * visual state\r\n             */\r\n            getLatestValues: function () { return latestValues; }, \r\n            /**\r\n             * Set the visiblity of the visual element. If it's changed, schedule\r\n             * a render to reflect these changes.\r\n             */\r\n            setVisibility: function (visibility) {\r\n                if (element.isVisible === visibility)\r\n                    return;\r\n                element.isVisible = visibility;\r\n                element.scheduleRender();\r\n            },\r\n            /**\r\n             * Make a target animatable by Popmotion. For instance, if we're\r\n             * trying to animate width from 100px to 100vw we need to measure 100vw\r\n             * in pixels to determine what we really need to animate to. This is also\r\n             * pluggable to support Framer's custom value types like Color,\r\n             * and CSS variables.\r\n             */\r\n            makeTargetAnimatable: function (target, canMutate) {\r\n                if (canMutate === void 0) { canMutate = true; }\r\n                return makeTargetAnimatable(element, target, props, canMutate);\r\n            },\r\n            // Motion values ========================\r\n            /**\r\n             * Add a motion value and bind it to this visual element.\r\n             */\r\n            addValue: function (key, value) {\r\n                // Remove existing value if it exists\r\n                if (element.hasValue(key))\r\n                    element.removeValue(key);\r\n                values.set(key, value);\r\n                latestValues[key] = value.get();\r\n                bindToMotionValue(key, value);\r\n            },\r\n            /**\r\n             * Remove a motion value and unbind any active subscriptions.\r\n             */\r\n            removeValue: function (key) {\r\n                var _a;\r\n                values.delete(key);\r\n                (_a = valueSubscriptions.get(key)) === null || _a === void 0 ? void 0 : _a();\r\n                valueSubscriptions.delete(key);\r\n                delete latestValues[key];\r\n                removeValueFromRenderState(key, renderState);\r\n            }, \r\n            /**\r\n             * Check whether we have a motion value for this key\r\n             */\r\n            hasValue: function (key) { return values.has(key); }, \r\n            /**\r\n             * Get a motion value for this key. If called with a default\r\n             * value, we'll create one if none exists.\r\n             */\r\n            getValue: function (key, defaultValue) {\r\n                var value = values.get(key);\r\n                if (value === undefined && defaultValue !== undefined) {\r\n                    value = motionValue(defaultValue);\r\n                    element.addValue(key, value);\r\n                }\r\n                return value;\r\n            }, \r\n            /**\r\n             * Iterate over our motion values.\r\n             */\r\n            forEachValue: function (callback) { return values.forEach(callback); }, \r\n            /**\r\n             * If we're trying to animate to a previously unencountered value,\r\n             * we need to check for it in our state and as a last resort read it\r\n             * directly from the instance (which might have performance implications).\r\n             */\r\n            readValue: function (key) { var _a; return (_a = latestValues[key]) !== null && _a !== void 0 ? _a : readValueFromInstance(instance, key, options); }, \r\n            /**\r\n             * Set the base target to later animate back to. This is currently\r\n             * only hydrated on creation and when we first read a value.\r\n             */\r\n            setBaseTarget: function (key, value) {\r\n                baseTarget[key] = value;\r\n            },\r\n            /**\r\n             * Find the base target for a value thats been removed from all animation\r\n             * props.\r\n             */\r\n            getBaseTarget: function (key) {\r\n                if (getBaseTarget) {\r\n                    var target = getBaseTarget(props, key);\r\n                    if (target !== undefined && !isMotionValue(target))\r\n                        return target;\r\n                }\r\n                return baseTarget[key];\r\n            } }, lifecycles), { \r\n            /**\r\n             * Build the renderer state based on the latest visual state.\r\n             */\r\n            build: function () {\r\n                triggerBuild();\r\n                return renderState;\r\n            },\r\n            /**\r\n             * Schedule a render on the next animation frame.\r\n             */\r\n            scheduleRender: function () {\r\n                sync.render(render, false, true);\r\n            }, \r\n            /**\r\n             * Synchronously fire render. It's prefered that we batch renders but\r\n             * in many circumstances, like layout measurement, we need to run this\r\n             * synchronously. However in those instances other measures should be taken\r\n             * to batch reads/writes.\r\n             */\r\n            syncRender: render, \r\n            /**\r\n             * Update the provided props. Ensure any newly-added motion values are\r\n             * added to our map, old ones removed, and listeners updated.\r\n             */\r\n            setProps: function (newProps) {\r\n                props = newProps;\r\n                lifecycles.updatePropListeners(newProps);\r\n                prevMotionValues = updateMotionValuesFromProps(element, scrapeMotionValuesFromProps(props), prevMotionValues);\r\n            }, getProps: function () { return props; }, \r\n            // Variants ==============================\r\n            /**\r\n             * Returns the variant definition with a given name.\r\n             */\r\n            getVariant: function (name) { var _a; return (_a = props.variants) === null || _a === void 0 ? void 0 : _a[name]; }, \r\n            /**\r\n             * Returns the defined default transition on this component.\r\n             */\r\n            getDefaultTransition: function () { return props.transition; }, \r\n            /**\r\n             * Used by child variant nodes to get the closest ancestor variant props.\r\n             */\r\n            getVariantContext: function (startAtParent) {\r\n                if (startAtParent === void 0) { startAtParent = false; }\r\n                if (startAtParent)\r\n                    return parent === null || parent === void 0 ? void 0 : parent.getVariantContext();\r\n                if (!isControllingVariants) {\r\n                    var context_1 = (parent === null || parent === void 0 ? void 0 : parent.getVariantContext()) || {};\r\n                    if (props.initial !== undefined) {\r\n                        context_1.initial = props.initial;\r\n                    }\r\n                    return context_1;\r\n                }\r\n                var context = {};\r\n                for (var i = 0; i < numVariantProps; i++) {\r\n                    var name_1 = variantProps[i];\r\n                    var prop = props[name_1];\r\n                    if (isVariantLabel(prop) || prop === false) {\r\n                        context[name_1] = prop;\r\n                    }\r\n                }\r\n                return context;\r\n            },\r\n            // Layout projection ==============================\r\n            /**\r\n             * Enable layout projection for this visual element. Won't actually\r\n             * occur until we also have hydrated layout measurements.\r\n             */\r\n            enableLayoutProjection: function () {\r\n                projection.isEnabled = true;\r\n                element.layoutTree.add(element);\r\n            },\r\n            /**\r\n             * Lock the projection target, for instance when dragging, so\r\n             * nothing else can try and animate it.\r\n             */\r\n            lockProjectionTarget: function () {\r\n                projection.isTargetLocked = true;\r\n            },\r\n            unlockProjectionTarget: function () {\r\n                element.stopLayoutAnimation();\r\n                projection.isTargetLocked = false;\r\n            }, getLayoutState: function () { return layoutState; }, setCrossfader: function (newCrossfader) {\r\n                crossfader = newCrossfader;\r\n            }, isProjectionReady: function () {\r\n                return projection.isEnabled &&\r\n                    projection.isHydrated &&\r\n                    layoutState.isHydrated;\r\n            }, \r\n            /**\r\n             * Start a layout animation on a given axis.\r\n             */\r\n            startLayoutAnimation: function (axis, transition, isRelative) {\r\n                if (isRelative === void 0) { isRelative = false; }\r\n                var progress = element.getProjectionAnimationProgress()[axis];\r\n                var _a = isRelative\r\n                    ? projection.relativeTarget[axis]\r\n                    : projection.target[axis], min = _a.min, max = _a.max;\r\n                var length = max - min;\r\n                progress.clearListeners();\r\n                progress.set(min);\r\n                progress.set(min); // Set twice to hard-reset velocity\r\n                progress.onChange(function (v) {\r\n                    element.setProjectionTargetAxis(axis, v, v + length, isRelative);\r\n                });\r\n                return element.animateMotionValue(axis, progress, 0, transition);\r\n            },\r\n            /**\r\n             * Stop layout animations.\r\n             */\r\n            stopLayoutAnimation: function () {\r\n                eachAxis(function (axis) {\r\n                    return element.getProjectionAnimationProgress()[axis].stop();\r\n                });\r\n            },\r\n            /**\r\n             * Measure the current viewport box with or without transforms.\r\n             * Only measures axis-aligned boxes, rotate and skew must be manually\r\n             * removed with a re-render to work.\r\n             */\r\n            measureViewportBox: function (withTransform) {\r\n                if (withTransform === void 0) { withTransform = true; }\r\n                var viewportBox = measureViewportBox(instance, options);\r\n                if (!withTransform)\r\n                    removeBoxTransforms(viewportBox, latestValues);\r\n                return viewportBox;\r\n            },\r\n            /**\r\n             * Get the motion values tracking the layout animations on each\r\n             * axis. Lazy init if not already created.\r\n             */\r\n            getProjectionAnimationProgress: function () {\r\n                projectionTargetProgress || (projectionTargetProgress = {\r\n                    x: motionValue(0),\r\n                    y: motionValue(0),\r\n                });\r\n                return projectionTargetProgress;\r\n            },\r\n            /**\r\n             * Update the projection of a single axis. Schedule an update to\r\n             * the tree layout projection.\r\n             */\r\n            setProjectionTargetAxis: function (axis, min, max, isRelative) {\r\n                if (isRelative === void 0) { isRelative = false; }\r\n                var target;\r\n                if (isRelative) {\r\n                    if (!projection.relativeTarget) {\r\n                        projection.relativeTarget = axisBox();\r\n                    }\r\n                    target = projection.relativeTarget[axis];\r\n                }\r\n                else {\r\n                    projection.relativeTarget = undefined;\r\n                    target = projection.target[axis];\r\n                }\r\n                projection.isHydrated = true;\r\n                target.min = min;\r\n                target.max = max;\r\n                // Flag that we want to fire the onViewportBoxUpdate event handler\r\n                hasViewportBoxUpdated = true;\r\n                lifecycles.notifySetAxisTarget();\r\n            },\r\n            /**\r\n             * Rebase the projection target on top of the provided viewport box\r\n             * or the measured layout. This ensures that non-animating elements\r\n             * don't fall out of sync differences in measurements vs projections\r\n             * after a page scroll or other relayout.\r\n             */\r\n            rebaseProjectionTarget: function (force, box) {\r\n                if (box === void 0) { box = layoutState.layout; }\r\n                var _a = element.getProjectionAnimationProgress(), x = _a.x, y = _a.y;\r\n                var shouldRebase = !projection.relativeTarget &&\r\n                    !projection.isTargetLocked &&\r\n                    !x.isAnimating() &&\r\n                    !y.isAnimating();\r\n                if (force || shouldRebase) {\r\n                    eachAxis(function (axis) {\r\n                        var _a = box[axis], min = _a.min, max = _a.max;\r\n                        element.setProjectionTargetAxis(axis, min, max);\r\n                    });\r\n                }\r\n            },\r\n            /**\r\n             * Notify the visual element that its layout is up-to-date.\r\n             * Currently Animate.tsx uses this to check whether a layout animation\r\n             * needs to be performed.\r\n             */\r\n            notifyLayoutReady: function (config) {\r\n                setCurrentViewportBox(element);\r\n                element.notifyLayoutUpdate(layoutState.layout, element.prevViewportBox || layoutState.layout, config);\r\n            }, \r\n            /**\r\n             * Temporarily reset the transform of the instance.\r\n             */\r\n            resetTransform: function () { return resetTransform(element, instance, props); }, restoreTransform: function () { return restoreTransform(instance, renderState); }, updateLayoutProjection: updateLayoutProjection,\r\n            updateTreeLayoutProjection: function () {\r\n                element.layoutTree.forEach(fireResolveRelativeTargetBox);\r\n                /**\r\n                 * Schedule the projection updates at the end of the current preRender\r\n                 * step. This will ensure that all layout trees will first resolve\r\n                 * relative projection boxes into viewport boxes, and *then*\r\n                 * update projections.\r\n                 */\r\n                sync.preRender(updateTreeLayoutProjection, false, true);\r\n                // sync.postRender(() => element.scheduleUpdateLayoutProjection())\r\n            },\r\n            getProjectionParent: function () {\r\n                if (projectionParent === undefined) {\r\n                    var foundParent = false;\r\n                    // Search backwards through the tree path\r\n                    for (var i = element.path.length - 1; i >= 0; i--) {\r\n                        var ancestor = element.path[i];\r\n                        if (ancestor.projection.isEnabled) {\r\n                            foundParent = ancestor;\r\n                            break;\r\n                        }\r\n                    }\r\n                    projectionParent = foundParent;\r\n                }\r\n                return projectionParent;\r\n            },\r\n            resolveRelativeTargetBox: function () {\r\n                var relativeParent = element.getProjectionParent();\r\n                if (!projection.relativeTarget || !relativeParent)\r\n                    return;\r\n                calcRelativeBox(projection, relativeParent.projection);\r\n                if (isDraggable(relativeParent)) {\r\n                    var target = projection.target;\r\n                    applyBoxTransforms(target, target, relativeParent.getLatestValues());\r\n                }\r\n            },\r\n            shouldResetTransform: function () {\r\n                return Boolean(props._layoutResetTransform);\r\n            },\r\n            /**\r\n             *\r\n             */\r\n            pointTo: function (newLead) {\r\n                leadProjection = newLead.projection;\r\n                leadLatestValues = newLead.getLatestValues();\r\n                /**\r\n                 * Subscribe to lead component's layout animations\r\n                 */\r\n                unsubscribeFromLeadVisualElement === null || unsubscribeFromLeadVisualElement === void 0 ? void 0 : unsubscribeFromLeadVisualElement();\r\n                unsubscribeFromLeadVisualElement = pipe(newLead.onSetAxisTarget(element.scheduleUpdateLayoutProjection), newLead.onLayoutAnimationComplete(function () {\r\n                    var _a;\r\n                    if (element.isPresent) {\r\n                        element.presence = Presence.Present;\r\n                    }\r\n                    else {\r\n                        (_a = element.layoutSafeToRemove) === null || _a === void 0 ? void 0 : _a.call(element);\r\n                    }\r\n                }));\r\n            }, \r\n            // TODO: Clean this up\r\n            isPresent: true, presence: Presence.Entering });\r\n        return element;\r\n    };\r\n};\r\nfunction fireResolveRelativeTargetBox(child) {\r\n    child.resolveRelativeTargetBox();\r\n}\r\nfunction fireUpdateLayoutProjection(child) {\r\n    child.updateLayoutProjection();\r\n}\r\nvar variantProps = __spreadArray([\"initial\"], __read(variantPriorityOrder));\r\nvar numVariantProps = variantProps.length;\r\n\r\nexport { visualElement };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}