{"ast":null,"code":"import { __assign, __read } from 'tslib';\nimport { number, px } from 'style-value-types';\nimport { isKeyframesTarget } from '../../../animation/utils/is-keyframes-target.js';\nimport { invariant } from 'hey-listen';\nimport { transformProps } from '../../html/utils/transform.js';\nimport { findDimensionValueType } from '../value-types/dimensions.js';\nvar positionalKeys = new Set([\"width\", \"height\", \"top\", \"left\", \"right\", \"bottom\", \"x\", \"y\"]);\nvar isPositionalKey = function (key) {\n  return positionalKeys.has(key);\n};\nvar hasPositionalKey = function (target) {\n  return Object.keys(target).some(isPositionalKey);\n};\nvar setAndResetVelocity = function (value, to) {\n  // Looks odd but setting it twice doesn't render, it'll just\n  // set both prev and current to the latest value\n  value.set(to, false);\n  value.set(to);\n};\nvar isNumOrPxType = function (v) {\n  return v === number || v === px;\n};\nvar BoundingBoxDimension;\n(function (BoundingBoxDimension) {\n  BoundingBoxDimension[\"width\"] = \"width\";\n  BoundingBoxDimension[\"height\"] = \"height\";\n  BoundingBoxDimension[\"left\"] = \"left\";\n  BoundingBoxDimension[\"right\"] = \"right\";\n  BoundingBoxDimension[\"top\"] = \"top\";\n  BoundingBoxDimension[\"bottom\"] = \"bottom\";\n})(BoundingBoxDimension || (BoundingBoxDimension = {}));\nvar getPosFromMatrix = function (matrix, pos) {\n  return parseFloat(matrix.split(\", \")[pos]);\n};\nvar getTranslateFromMatrix = function (pos2, pos3) {\n  return function (_bbox, _a) {\n    var transform = _a.transform;\n    if (transform === \"none\" || !transform) return 0;\n    var matrix3d = transform.match(/^matrix3d\\((.+)\\)$/);\n    if (matrix3d) {\n      return getPosFromMatrix(matrix3d[1], pos3);\n    } else {\n      var matrix = transform.match(/^matrix\\((.+)\\)$/);\n      if (matrix) {\n        return getPosFromMatrix(matrix[1], pos2);\n      } else {\n        return 0;\n      }\n    }\n  };\n};\nvar transformKeys = new Set([\"x\", \"y\", \"z\"]);\nvar nonTranslationalTransformKeys = transformProps.filter(function (key) {\n  return !transformKeys.has(key);\n});\nfunction removeNonTranslationalTransform(visualElement) {\n  var removedTransforms = [];\n  nonTranslationalTransformKeys.forEach(function (key) {\n    var value = visualElement.getValue(key);\n    if (value !== undefined) {\n      removedTransforms.push([key, value.get()]);\n      value.set(key.startsWith(\"scale\") ? 1 : 0);\n    }\n  });\n  // Apply changes to element before measurement\n  if (removedTransforms.length) visualElement.syncRender();\n  return removedTransforms;\n}\nvar positionalValues = {\n  // Dimensions\n  width: function (_a) {\n    var x = _a.x;\n    return x.max - x.min;\n  },\n  height: function (_a) {\n    var y = _a.y;\n    return y.max - y.min;\n  },\n  top: function (_bbox, _a) {\n    var top = _a.top;\n    return parseFloat(top);\n  },\n  left: function (_bbox, _a) {\n    var left = _a.left;\n    return parseFloat(left);\n  },\n  bottom: function (_a, _b) {\n    var y = _a.y;\n    var top = _b.top;\n    return parseFloat(top) + (y.max - y.min);\n  },\n  right: function (_a, _b) {\n    var x = _a.x;\n    var left = _b.left;\n    return parseFloat(left) + (x.max - x.min);\n  },\n  // Transform\n  x: getTranslateFromMatrix(4, 13),\n  y: getTranslateFromMatrix(5, 14)\n};\nvar convertChangedValueTypes = function (target, visualElement, changedKeys) {\n  var originBbox = visualElement.measureViewportBox();\n  var element = visualElement.getInstance();\n  var elementComputedStyle = getComputedStyle(element);\n  var display = elementComputedStyle.display,\n    top = elementComputedStyle.top,\n    left = elementComputedStyle.left,\n    bottom = elementComputedStyle.bottom,\n    right = elementComputedStyle.right,\n    transform = elementComputedStyle.transform;\n  var originComputedStyle = {\n    top: top,\n    left: left,\n    bottom: bottom,\n    right: right,\n    transform: transform\n  };\n  // If the element is currently set to display: \"none\", make it visible before\n  // measuring the target bounding box\n  if (display === \"none\") {\n    visualElement.setStaticValue(\"display\", target.display || \"block\");\n  }\n  // Apply the latest values (as set in checkAndConvertChangedValueTypes)\n  visualElement.syncRender();\n  var targetBbox = visualElement.measureViewportBox();\n  changedKeys.forEach(function (key) {\n    // Restore styles to their **calculated computed style**, not their actual\n    // originally set style. This allows us to animate between equivalent pixel units.\n    var value = visualElement.getValue(key);\n    setAndResetVelocity(value, positionalValues[key](originBbox, originComputedStyle));\n    target[key] = positionalValues[key](targetBbox, elementComputedStyle);\n  });\n  return target;\n};\nvar checkAndConvertChangedValueTypes = function (visualElement, target, origin, transitionEnd) {\n  if (origin === void 0) {\n    origin = {};\n  }\n  if (transitionEnd === void 0) {\n    transitionEnd = {};\n  }\n  target = __assign({}, target);\n  transitionEnd = __assign({}, transitionEnd);\n  var targetPositionalKeys = Object.keys(target).filter(isPositionalKey);\n  // We want to remove any transform values that could affect the element's bounding box before\n  // it's measured. We'll reapply these later.\n  var removedTransformValues = [];\n  var hasAttemptedToRemoveTransformValues = false;\n  var changedValueTypeKeys = [];\n  targetPositionalKeys.forEach(function (key) {\n    var value = visualElement.getValue(key);\n    if (!visualElement.hasValue(key)) return;\n    var from = origin[key];\n    var to = target[key];\n    var fromType = findDimensionValueType(from);\n    var toType;\n    // TODO: The current implementation of this basically throws an error\n    // if you try and do value conversion via keyframes. There's probably\n    // a way of doing this but the performance implications would need greater scrutiny,\n    // as it'd be doing multiple resize-remeasure operations.\n    if (isKeyframesTarget(to)) {\n      var numKeyframes = to.length;\n      for (var i = to[0] === null ? 1 : 0; i < numKeyframes; i++) {\n        if (!toType) {\n          toType = findDimensionValueType(to[i]);\n          invariant(toType === fromType || isNumOrPxType(fromType) && isNumOrPxType(toType), \"Keyframes must be of the same dimension as the current value\");\n        } else {\n          invariant(findDimensionValueType(to[i]) === toType, \"All keyframes must be of the same type\");\n        }\n      }\n    } else {\n      toType = findDimensionValueType(to);\n    }\n    if (fromType !== toType) {\n      // If they're both just number or px, convert them both to numbers rather than\n      // relying on resize/remeasure to convert (which is wasteful in this situation)\n      if (isNumOrPxType(fromType) && isNumOrPxType(toType)) {\n        var current = value.get();\n        if (typeof current === \"string\") {\n          value.set(parseFloat(current));\n        }\n        if (typeof to === \"string\") {\n          target[key] = parseFloat(to);\n        } else if (Array.isArray(to) && toType === px) {\n          target[key] = to.map(parseFloat);\n        }\n      } else if ((fromType === null || fromType === void 0 ? void 0 : fromType.transform) && (toType === null || toType === void 0 ? void 0 : toType.transform) && (from === 0 || to === 0)) {\n        // If one or the other value is 0, it's safe to coerce it to the\n        // type of the other without measurement\n        if (from === 0) {\n          value.set(toType.transform(from));\n        } else {\n          target[key] = fromType.transform(to);\n        }\n      } else {\n        // If we're going to do value conversion via DOM measurements, we first\n        // need to remove non-positional transform values that could affect the bbox measurements.\n        if (!hasAttemptedToRemoveTransformValues) {\n          removedTransformValues = removeNonTranslationalTransform(visualElement);\n          hasAttemptedToRemoveTransformValues = true;\n        }\n        changedValueTypeKeys.push(key);\n        transitionEnd[key] = transitionEnd[key] !== undefined ? transitionEnd[key] : target[key];\n        setAndResetVelocity(value, to);\n      }\n    }\n  });\n  if (changedValueTypeKeys.length) {\n    var convertedTarget = convertChangedValueTypes(target, visualElement, changedValueTypeKeys);\n    // If we removed transform values, reapply them before the next render\n    if (removedTransformValues.length) {\n      removedTransformValues.forEach(function (_a) {\n        var _b = __read(_a, 2),\n          key = _b[0],\n          value = _b[1];\n        visualElement.getValue(key).set(value);\n      });\n    }\n    // Reapply original values\n    visualElement.syncRender();\n    return {\n      target: convertedTarget,\n      transitionEnd: transitionEnd\n    };\n  } else {\n    return {\n      target: target,\n      transitionEnd: transitionEnd\n    };\n  }\n};\n/**\r\n * Convert value types for x/y/width/height/top/left/bottom/right\r\n *\r\n * Allows animation between `'auto'` -> `'100%'` or `0` -> `'calc(50% - 10vw)'`\r\n *\r\n * @internal\r\n */\nfunction unitConversion(visualElement, target, origin, transitionEnd) {\n  return hasPositionalKey(target) ? checkAndConvertChangedValueTypes(visualElement, target, origin, transitionEnd) : {\n    target: target,\n    transitionEnd: transitionEnd\n  };\n}\nexport { BoundingBoxDimension, unitConversion };","map":{"version":3,"names":["__assign","__read","number","px","isKeyframesTarget","invariant","transformProps","findDimensionValueType","positionalKeys","Set","isPositionalKey","key","has","hasPositionalKey","target","Object","keys","some","setAndResetVelocity","value","to","set","isNumOrPxType","v","BoundingBoxDimension","getPosFromMatrix","matrix","pos","parseFloat","split","getTranslateFromMatrix","pos2","pos3","_bbox","_a","transform","matrix3d","match","transformKeys","nonTranslationalTransformKeys","filter","removeNonTranslationalTransform","visualElement","removedTransforms","forEach","getValue","undefined","push","get","startsWith","length","syncRender","positionalValues","width","x","max","min","height","y","top","left","bottom","_b","right","convertChangedValueTypes","changedKeys","originBbox","measureViewportBox","element","getInstance","elementComputedStyle","getComputedStyle","display","originComputedStyle","setStaticValue","targetBbox","checkAndConvertChangedValueTypes","origin","transitionEnd","targetPositionalKeys","removedTransformValues","hasAttemptedToRemoveTransformValues","changedValueTypeKeys","hasValue","from","fromType","toType","numKeyframes","i","current","Array","isArray","map","convertedTarget","unitConversion"],"sources":["E:/Hasan sir project/4/frontend/node_modules/framer-motion/dist/es/render/dom/utils/unit-conversion.js"],"sourcesContent":["import { __assign, __read } from 'tslib';\r\nimport { number, px } from 'style-value-types';\r\nimport { isKeyframesTarget } from '../../../animation/utils/is-keyframes-target.js';\r\nimport { invariant } from 'hey-listen';\r\nimport { transformProps } from '../../html/utils/transform.js';\r\nimport { findDimensionValueType } from '../value-types/dimensions.js';\r\n\r\nvar positionalKeys = new Set([\r\n    \"width\",\r\n    \"height\",\r\n    \"top\",\r\n    \"left\",\r\n    \"right\",\r\n    \"bottom\",\r\n    \"x\",\r\n    \"y\",\r\n]);\r\nvar isPositionalKey = function (key) { return positionalKeys.has(key); };\r\nvar hasPositionalKey = function (target) {\r\n    return Object.keys(target).some(isPositionalKey);\r\n};\r\nvar setAndResetVelocity = function (value, to) {\r\n    // Looks odd but setting it twice doesn't render, it'll just\r\n    // set both prev and current to the latest value\r\n    value.set(to, false);\r\n    value.set(to);\r\n};\r\nvar isNumOrPxType = function (v) {\r\n    return v === number || v === px;\r\n};\r\nvar BoundingBoxDimension;\r\n(function (BoundingBoxDimension) {\r\n    BoundingBoxDimension[\"width\"] = \"width\";\r\n    BoundingBoxDimension[\"height\"] = \"height\";\r\n    BoundingBoxDimension[\"left\"] = \"left\";\r\n    BoundingBoxDimension[\"right\"] = \"right\";\r\n    BoundingBoxDimension[\"top\"] = \"top\";\r\n    BoundingBoxDimension[\"bottom\"] = \"bottom\";\r\n})(BoundingBoxDimension || (BoundingBoxDimension = {}));\r\nvar getPosFromMatrix = function (matrix, pos) {\r\n    return parseFloat(matrix.split(\", \")[pos]);\r\n};\r\nvar getTranslateFromMatrix = function (pos2, pos3) { return function (_bbox, _a) {\r\n    var transform = _a.transform;\r\n    if (transform === \"none\" || !transform)\r\n        return 0;\r\n    var matrix3d = transform.match(/^matrix3d\\((.+)\\)$/);\r\n    if (matrix3d) {\r\n        return getPosFromMatrix(matrix3d[1], pos3);\r\n    }\r\n    else {\r\n        var matrix = transform.match(/^matrix\\((.+)\\)$/);\r\n        if (matrix) {\r\n            return getPosFromMatrix(matrix[1], pos2);\r\n        }\r\n        else {\r\n            return 0;\r\n        }\r\n    }\r\n}; };\r\nvar transformKeys = new Set([\"x\", \"y\", \"z\"]);\r\nvar nonTranslationalTransformKeys = transformProps.filter(function (key) { return !transformKeys.has(key); });\r\nfunction removeNonTranslationalTransform(visualElement) {\r\n    var removedTransforms = [];\r\n    nonTranslationalTransformKeys.forEach(function (key) {\r\n        var value = visualElement.getValue(key);\r\n        if (value !== undefined) {\r\n            removedTransforms.push([key, value.get()]);\r\n            value.set(key.startsWith(\"scale\") ? 1 : 0);\r\n        }\r\n    });\r\n    // Apply changes to element before measurement\r\n    if (removedTransforms.length)\r\n        visualElement.syncRender();\r\n    return removedTransforms;\r\n}\r\nvar positionalValues = {\r\n    // Dimensions\r\n    width: function (_a) {\r\n        var x = _a.x;\r\n        return x.max - x.min;\r\n    },\r\n    height: function (_a) {\r\n        var y = _a.y;\r\n        return y.max - y.min;\r\n    },\r\n    top: function (_bbox, _a) {\r\n        var top = _a.top;\r\n        return parseFloat(top);\r\n    },\r\n    left: function (_bbox, _a) {\r\n        var left = _a.left;\r\n        return parseFloat(left);\r\n    },\r\n    bottom: function (_a, _b) {\r\n        var y = _a.y;\r\n        var top = _b.top;\r\n        return parseFloat(top) + (y.max - y.min);\r\n    },\r\n    right: function (_a, _b) {\r\n        var x = _a.x;\r\n        var left = _b.left;\r\n        return parseFloat(left) + (x.max - x.min);\r\n    },\r\n    // Transform\r\n    x: getTranslateFromMatrix(4, 13),\r\n    y: getTranslateFromMatrix(5, 14),\r\n};\r\nvar convertChangedValueTypes = function (target, visualElement, changedKeys) {\r\n    var originBbox = visualElement.measureViewportBox();\r\n    var element = visualElement.getInstance();\r\n    var elementComputedStyle = getComputedStyle(element);\r\n    var display = elementComputedStyle.display, top = elementComputedStyle.top, left = elementComputedStyle.left, bottom = elementComputedStyle.bottom, right = elementComputedStyle.right, transform = elementComputedStyle.transform;\r\n    var originComputedStyle = { top: top, left: left, bottom: bottom, right: right, transform: transform };\r\n    // If the element is currently set to display: \"none\", make it visible before\r\n    // measuring the target bounding box\r\n    if (display === \"none\") {\r\n        visualElement.setStaticValue(\"display\", target.display || \"block\");\r\n    }\r\n    // Apply the latest values (as set in checkAndConvertChangedValueTypes)\r\n    visualElement.syncRender();\r\n    var targetBbox = visualElement.measureViewportBox();\r\n    changedKeys.forEach(function (key) {\r\n        // Restore styles to their **calculated computed style**, not their actual\r\n        // originally set style. This allows us to animate between equivalent pixel units.\r\n        var value = visualElement.getValue(key);\r\n        setAndResetVelocity(value, positionalValues[key](originBbox, originComputedStyle));\r\n        target[key] = positionalValues[key](targetBbox, elementComputedStyle);\r\n    });\r\n    return target;\r\n};\r\nvar checkAndConvertChangedValueTypes = function (visualElement, target, origin, transitionEnd) {\r\n    if (origin === void 0) { origin = {}; }\r\n    if (transitionEnd === void 0) { transitionEnd = {}; }\r\n    target = __assign({}, target);\r\n    transitionEnd = __assign({}, transitionEnd);\r\n    var targetPositionalKeys = Object.keys(target).filter(isPositionalKey);\r\n    // We want to remove any transform values that could affect the element's bounding box before\r\n    // it's measured. We'll reapply these later.\r\n    var removedTransformValues = [];\r\n    var hasAttemptedToRemoveTransformValues = false;\r\n    var changedValueTypeKeys = [];\r\n    targetPositionalKeys.forEach(function (key) {\r\n        var value = visualElement.getValue(key);\r\n        if (!visualElement.hasValue(key))\r\n            return;\r\n        var from = origin[key];\r\n        var to = target[key];\r\n        var fromType = findDimensionValueType(from);\r\n        var toType;\r\n        // TODO: The current implementation of this basically throws an error\r\n        // if you try and do value conversion via keyframes. There's probably\r\n        // a way of doing this but the performance implications would need greater scrutiny,\r\n        // as it'd be doing multiple resize-remeasure operations.\r\n        if (isKeyframesTarget(to)) {\r\n            var numKeyframes = to.length;\r\n            for (var i = to[0] === null ? 1 : 0; i < numKeyframes; i++) {\r\n                if (!toType) {\r\n                    toType = findDimensionValueType(to[i]);\r\n                    invariant(toType === fromType ||\r\n                        (isNumOrPxType(fromType) && isNumOrPxType(toType)), \"Keyframes must be of the same dimension as the current value\");\r\n                }\r\n                else {\r\n                    invariant(findDimensionValueType(to[i]) === toType, \"All keyframes must be of the same type\");\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            toType = findDimensionValueType(to);\r\n        }\r\n        if (fromType !== toType) {\r\n            // If they're both just number or px, convert them both to numbers rather than\r\n            // relying on resize/remeasure to convert (which is wasteful in this situation)\r\n            if (isNumOrPxType(fromType) && isNumOrPxType(toType)) {\r\n                var current = value.get();\r\n                if (typeof current === \"string\") {\r\n                    value.set(parseFloat(current));\r\n                }\r\n                if (typeof to === \"string\") {\r\n                    target[key] = parseFloat(to);\r\n                }\r\n                else if (Array.isArray(to) && toType === px) {\r\n                    target[key] = to.map(parseFloat);\r\n                }\r\n            }\r\n            else if ((fromType === null || fromType === void 0 ? void 0 : fromType.transform) &&\r\n                (toType === null || toType === void 0 ? void 0 : toType.transform) &&\r\n                (from === 0 || to === 0)) {\r\n                // If one or the other value is 0, it's safe to coerce it to the\r\n                // type of the other without measurement\r\n                if (from === 0) {\r\n                    value.set(toType.transform(from));\r\n                }\r\n                else {\r\n                    target[key] = fromType.transform(to);\r\n                }\r\n            }\r\n            else {\r\n                // If we're going to do value conversion via DOM measurements, we first\r\n                // need to remove non-positional transform values that could affect the bbox measurements.\r\n                if (!hasAttemptedToRemoveTransformValues) {\r\n                    removedTransformValues = removeNonTranslationalTransform(visualElement);\r\n                    hasAttemptedToRemoveTransformValues = true;\r\n                }\r\n                changedValueTypeKeys.push(key);\r\n                transitionEnd[key] =\r\n                    transitionEnd[key] !== undefined\r\n                        ? transitionEnd[key]\r\n                        : target[key];\r\n                setAndResetVelocity(value, to);\r\n            }\r\n        }\r\n    });\r\n    if (changedValueTypeKeys.length) {\r\n        var convertedTarget = convertChangedValueTypes(target, visualElement, changedValueTypeKeys);\r\n        // If we removed transform values, reapply them before the next render\r\n        if (removedTransformValues.length) {\r\n            removedTransformValues.forEach(function (_a) {\r\n                var _b = __read(_a, 2), key = _b[0], value = _b[1];\r\n                visualElement.getValue(key).set(value);\r\n            });\r\n        }\r\n        // Reapply original values\r\n        visualElement.syncRender();\r\n        return { target: convertedTarget, transitionEnd: transitionEnd };\r\n    }\r\n    else {\r\n        return { target: target, transitionEnd: transitionEnd };\r\n    }\r\n};\r\n/**\r\n * Convert value types for x/y/width/height/top/left/bottom/right\r\n *\r\n * Allows animation between `'auto'` -> `'100%'` or `0` -> `'calc(50% - 10vw)'`\r\n *\r\n * @internal\r\n */\r\nfunction unitConversion(visualElement, target, origin, transitionEnd) {\r\n    return hasPositionalKey(target)\r\n        ? checkAndConvertChangedValueTypes(visualElement, target, origin, transitionEnd)\r\n        : { target: target, transitionEnd: transitionEnd };\r\n}\r\n\r\nexport { BoundingBoxDimension, unitConversion };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}