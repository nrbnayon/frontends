{"ast":null,"code":"import { __read } from 'tslib';\nimport { mix } from 'popmotion';\n\n/**\r\n * Apply constraints to a point. These constraints are both physical along an\r\n * axis, and an elastic factor that determines how much to constrain the point\r\n * by if it does lie outside the defined parameters.\r\n */\nfunction applyConstraints(point, _a, elastic) {\n  var min = _a.min,\n    max = _a.max;\n  if (min !== undefined && point < min) {\n    // If we have a min point defined, and this is outside of that, constrain\n    point = elastic ? mix(min, point, elastic.min) : Math.max(point, min);\n  } else if (max !== undefined && point > max) {\n    // If we have a max point defined, and this is outside of that, constrain\n    point = elastic ? mix(max, point, elastic.max) : Math.min(point, max);\n  }\n  return point;\n}\n/**\r\n * Calculates a min projection point based on a pointer, pointer progress\r\n * within the drag target, and constraints.\r\n *\r\n * For instance if an element was 100px width, we were dragging from 0.25\r\n * along this axis, the pointer is at 200px, and there were no constraints,\r\n * we would calculate a min projection point of 175px.\r\n */\nfunction calcConstrainedMinPoint(point, length, progress, constraints, elastic) {\n  // Calculate a min point for this axis and apply it to the current pointer\n  var min = point - length * progress;\n  return constraints ? applyConstraints(min, constraints, elastic) : min;\n}\n/**\r\n * Calculate constraints in terms of the viewport when defined relatively to the\r\n * measured axis. This is measured from the nearest edge, so a max constraint of 200\r\n * on an axis with a max value of 300 would return a constraint of 500 - axis length\r\n */\nfunction calcRelativeAxisConstraints(axis, min, max) {\n  return {\n    min: min !== undefined ? axis.min + min : undefined,\n    max: max !== undefined ? axis.max + max - (axis.max - axis.min) : undefined\n  };\n}\n/**\r\n * Calculate constraints in terms of the viewport when\r\n * defined relatively to the measured bounding box.\r\n */\nfunction calcRelativeConstraints(layoutBox, _a) {\n  var top = _a.top,\n    left = _a.left,\n    bottom = _a.bottom,\n    right = _a.right;\n  return {\n    x: calcRelativeAxisConstraints(layoutBox.x, left, right),\n    y: calcRelativeAxisConstraints(layoutBox.y, top, bottom)\n  };\n}\n/**\r\n * Calculate viewport constraints when defined as another viewport-relative axis\r\n */\nfunction calcViewportAxisConstraints(layoutAxis, constraintsAxis) {\n  var _a;\n  var min = constraintsAxis.min - layoutAxis.min;\n  var max = constraintsAxis.max - layoutAxis.max;\n  // If the constraints axis is actually smaller than the layout axis then we can\n  // flip the constraints\n  if (constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min) {\n    _a = __read([max, min], 2), min = _a[0], max = _a[1];\n  }\n  return {\n    min: layoutAxis.min + min,\n    max: layoutAxis.min + max\n  };\n}\n/**\r\n * Calculate viewport constraints when defined as another viewport-relative box\r\n */\nfunction calcViewportConstraints(layoutBox, constraintsBox) {\n  return {\n    x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),\n    y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y)\n  };\n}\n/**\r\n * Calculate the an axis position based on two axes and a progress value.\r\n */\nfunction calcPositionFromProgress(axis, constraints, progress) {\n  var axisLength = axis.max - axis.min;\n  var min = mix(constraints.min, constraints.max - axisLength, progress);\n  return {\n    min: min,\n    max: min + axisLength\n  };\n}\n/**\r\n * Rebase the calculated viewport constraints relative to the layout.min point.\r\n */\nfunction rebaseAxisConstraints(layout, constraints) {\n  var relativeConstraints = {};\n  if (constraints.min !== undefined) {\n    relativeConstraints.min = constraints.min - layout.min;\n  }\n  if (constraints.max !== undefined) {\n    relativeConstraints.max = constraints.max - layout.min;\n  }\n  return relativeConstraints;\n}\nvar defaultElastic = 0.35;\n/**\r\n * Accepts a dragElastic prop and returns resolved elastic values for each axis.\r\n */\nfunction resolveDragElastic(dragElastic) {\n  if (dragElastic === false) {\n    dragElastic = 0;\n  } else if (dragElastic === true) {\n    dragElastic = defaultElastic;\n  }\n  return {\n    x: resolveAxisElastic(dragElastic, \"left\", \"right\"),\n    y: resolveAxisElastic(dragElastic, \"top\", \"bottom\")\n  };\n}\nfunction resolveAxisElastic(dragElastic, minLabel, maxLabel) {\n  return {\n    min: resolvePointElastic(dragElastic, minLabel),\n    max: resolvePointElastic(dragElastic, maxLabel)\n  };\n}\nfunction resolvePointElastic(dragElastic, label) {\n  var _a;\n  return typeof dragElastic === \"number\" ? dragElastic : (_a = dragElastic[label]) !== null && _a !== void 0 ? _a : 0;\n}\nexport { applyConstraints, calcConstrainedMinPoint, calcPositionFromProgress, calcRelativeAxisConstraints, calcRelativeConstraints, calcViewportAxisConstraints, calcViewportConstraints, defaultElastic, rebaseAxisConstraints, resolveAxisElastic, resolveDragElastic, resolvePointElastic };","map":{"version":3,"names":["__read","mix","applyConstraints","point","_a","elastic","min","max","undefined","Math","calcConstrainedMinPoint","length","progress","constraints","calcRelativeAxisConstraints","axis","calcRelativeConstraints","layoutBox","top","left","bottom","right","x","y","calcViewportAxisConstraints","layoutAxis","constraintsAxis","calcViewportConstraints","constraintsBox","calcPositionFromProgress","axisLength","rebaseAxisConstraints","layout","relativeConstraints","defaultElastic","resolveDragElastic","dragElastic","resolveAxisElastic","minLabel","maxLabel","resolvePointElastic","label"],"sources":["E:/Hasan sir project/ChattersTwo/frontend/node_modules/framer-motion/dist/es/gestures/drag/utils/constraints.js"],"sourcesContent":["import { __read } from 'tslib';\r\nimport { mix } from 'popmotion';\r\n\r\n/**\r\n * Apply constraints to a point. These constraints are both physical along an\r\n * axis, and an elastic factor that determines how much to constrain the point\r\n * by if it does lie outside the defined parameters.\r\n */\r\nfunction applyConstraints(point, _a, elastic) {\r\n    var min = _a.min, max = _a.max;\r\n    if (min !== undefined && point < min) {\r\n        // If we have a min point defined, and this is outside of that, constrain\r\n        point = elastic ? mix(min, point, elastic.min) : Math.max(point, min);\r\n    }\r\n    else if (max !== undefined && point > max) {\r\n        // If we have a max point defined, and this is outside of that, constrain\r\n        point = elastic ? mix(max, point, elastic.max) : Math.min(point, max);\r\n    }\r\n    return point;\r\n}\r\n/**\r\n * Calculates a min projection point based on a pointer, pointer progress\r\n * within the drag target, and constraints.\r\n *\r\n * For instance if an element was 100px width, we were dragging from 0.25\r\n * along this axis, the pointer is at 200px, and there were no constraints,\r\n * we would calculate a min projection point of 175px.\r\n */\r\nfunction calcConstrainedMinPoint(point, length, progress, constraints, elastic) {\r\n    // Calculate a min point for this axis and apply it to the current pointer\r\n    var min = point - length * progress;\r\n    return constraints ? applyConstraints(min, constraints, elastic) : min;\r\n}\r\n/**\r\n * Calculate constraints in terms of the viewport when defined relatively to the\r\n * measured axis. This is measured from the nearest edge, so a max constraint of 200\r\n * on an axis with a max value of 300 would return a constraint of 500 - axis length\r\n */\r\nfunction calcRelativeAxisConstraints(axis, min, max) {\r\n    return {\r\n        min: min !== undefined ? axis.min + min : undefined,\r\n        max: max !== undefined\r\n            ? axis.max + max - (axis.max - axis.min)\r\n            : undefined,\r\n    };\r\n}\r\n/**\r\n * Calculate constraints in terms of the viewport when\r\n * defined relatively to the measured bounding box.\r\n */\r\nfunction calcRelativeConstraints(layoutBox, _a) {\r\n    var top = _a.top, left = _a.left, bottom = _a.bottom, right = _a.right;\r\n    return {\r\n        x: calcRelativeAxisConstraints(layoutBox.x, left, right),\r\n        y: calcRelativeAxisConstraints(layoutBox.y, top, bottom),\r\n    };\r\n}\r\n/**\r\n * Calculate viewport constraints when defined as another viewport-relative axis\r\n */\r\nfunction calcViewportAxisConstraints(layoutAxis, constraintsAxis) {\r\n    var _a;\r\n    var min = constraintsAxis.min - layoutAxis.min;\r\n    var max = constraintsAxis.max - layoutAxis.max;\r\n    // If the constraints axis is actually smaller than the layout axis then we can\r\n    // flip the constraints\r\n    if (constraintsAxis.max - constraintsAxis.min <\r\n        layoutAxis.max - layoutAxis.min) {\r\n        _a = __read([max, min], 2), min = _a[0], max = _a[1];\r\n    }\r\n    return {\r\n        min: layoutAxis.min + min,\r\n        max: layoutAxis.min + max,\r\n    };\r\n}\r\n/**\r\n * Calculate viewport constraints when defined as another viewport-relative box\r\n */\r\nfunction calcViewportConstraints(layoutBox, constraintsBox) {\r\n    return {\r\n        x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),\r\n        y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y),\r\n    };\r\n}\r\n/**\r\n * Calculate the an axis position based on two axes and a progress value.\r\n */\r\nfunction calcPositionFromProgress(axis, constraints, progress) {\r\n    var axisLength = axis.max - axis.min;\r\n    var min = mix(constraints.min, constraints.max - axisLength, progress);\r\n    return { min: min, max: min + axisLength };\r\n}\r\n/**\r\n * Rebase the calculated viewport constraints relative to the layout.min point.\r\n */\r\nfunction rebaseAxisConstraints(layout, constraints) {\r\n    var relativeConstraints = {};\r\n    if (constraints.min !== undefined) {\r\n        relativeConstraints.min = constraints.min - layout.min;\r\n    }\r\n    if (constraints.max !== undefined) {\r\n        relativeConstraints.max = constraints.max - layout.min;\r\n    }\r\n    return relativeConstraints;\r\n}\r\nvar defaultElastic = 0.35;\r\n/**\r\n * Accepts a dragElastic prop and returns resolved elastic values for each axis.\r\n */\r\nfunction resolveDragElastic(dragElastic) {\r\n    if (dragElastic === false) {\r\n        dragElastic = 0;\r\n    }\r\n    else if (dragElastic === true) {\r\n        dragElastic = defaultElastic;\r\n    }\r\n    return {\r\n        x: resolveAxisElastic(dragElastic, \"left\", \"right\"),\r\n        y: resolveAxisElastic(dragElastic, \"top\", \"bottom\"),\r\n    };\r\n}\r\nfunction resolveAxisElastic(dragElastic, minLabel, maxLabel) {\r\n    return {\r\n        min: resolvePointElastic(dragElastic, minLabel),\r\n        max: resolvePointElastic(dragElastic, maxLabel),\r\n    };\r\n}\r\nfunction resolvePointElastic(dragElastic, label) {\r\n    var _a;\r\n    return typeof dragElastic === \"number\"\r\n        ? dragElastic\r\n        : (_a = dragElastic[label]) !== null && _a !== void 0 ? _a : 0;\r\n}\r\n\r\nexport { applyConstraints, calcConstrainedMinPoint, calcPositionFromProgress, calcRelativeAxisConstraints, calcRelativeConstraints, calcViewportAxisConstraints, calcViewportConstraints, defaultElastic, rebaseAxisConstraints, resolveAxisElastic, resolveDragElastic, resolvePointElastic };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}