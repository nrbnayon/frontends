{"ast":null,"code":"import { getLastItem } from \"./array\";\nimport { isArray, isObject } from \"./assertion\";\nimport { objectKeys } from \"./object\";\nexport var breakpoints = Object.freeze([\"base\", \"sm\", \"md\", \"lg\", \"xl\", \"2xl\"]);\nexport function mapResponsive(prop, mapper) {\n  if (isArray(prop)) {\n    return prop.map(item => {\n      if (item === null) {\n        return null;\n      }\n      return mapper(item);\n    });\n  }\n  if (isObject(prop)) {\n    return objectKeys(prop).reduce((result, key) => {\n      result[key] = mapper(prop[key]);\n      return result;\n    }, {});\n  }\n  if (prop != null) {\n    return mapper(prop);\n  }\n  return null;\n}\nexport function objectToArrayNotation(obj, bps) {\n  if (bps === void 0) {\n    bps = breakpoints;\n  }\n  var result = bps.map(br => {\n    var _obj$br;\n    return (_obj$br = obj[br]) != null ? _obj$br : null;\n  });\n  while (getLastItem(result) === null) {\n    result.pop();\n  }\n  return result;\n}\nexport function arrayToObjectNotation(values, bps) {\n  if (bps === void 0) {\n    bps = breakpoints;\n  }\n  var result = {};\n  values.forEach((value, index) => {\n    var key = bps[index];\n    if (value == null) return;\n    result[key] = value;\n  });\n  return result;\n}\nexport function isResponsiveObjectLike(obj, bps) {\n  if (bps === void 0) {\n    bps = breakpoints;\n  }\n  var keys = Object.keys(obj);\n  return keys.length > 0 && keys.every(key => bps.includes(key));\n}\n/**\r\n * since breakpoints are defined as custom properties on an array, you may\r\n * `Object.keys(theme.breakpoints)` to retrieve both regular numeric indices\r\n * and custom breakpoints as string.\r\n *\r\n * This function returns true given a custom array property.\r\n */\n\nexport var isCustomBreakpoint = maybeBreakpoint => Number.isNaN(Number(maybeBreakpoint));","map":{"version":3,"names":["getLastItem","isArray","isObject","objectKeys","breakpoints","Object","freeze","mapResponsive","prop","mapper","map","item","reduce","result","key","objectToArrayNotation","obj","bps","br","_obj$br","pop","arrayToObjectNotation","values","forEach","value","index","isResponsiveObjectLike","keys","length","every","includes","isCustomBreakpoint","maybeBreakpoint","Number","isNaN"],"sources":["../../src/responsive.ts"],"sourcesContent":["import { getLastItem } from \"./array\"\nimport { isArray, isObject } from \"./assertion\"\nimport { objectKeys } from \"./object\"\nimport { Dict } from \"./types\"\n\nexport const breakpoints = Object.freeze([\n  \"base\",\n  \"sm\",\n  \"md\",\n  \"lg\",\n  \"xl\",\n  \"2xl\",\n])\n\nexport function mapResponsive(prop: any, mapper: (val: any) => any) {\n  if (isArray(prop)) {\n    return prop.map((item) => {\n      if (item === null) {\n        return null\n      }\n      return mapper(item)\n    })\n  }\n\n  if (isObject(prop)) {\n    return objectKeys(prop).reduce((result: Dict, key) => {\n      result[key] = mapper(prop[key])\n      return result\n    }, {})\n  }\n\n  if (prop != null) {\n    return mapper(prop)\n  }\n\n  return null\n}\n\nexport function objectToArrayNotation(obj: Dict, bps = breakpoints) {\n  const result = bps.map((br) => obj[br] ?? null)\n  while (getLastItem(result) === null) {\n    result.pop()\n  }\n  return result\n}\n\nexport function arrayToObjectNotation(values: any[], bps = breakpoints) {\n  const result = {} as Dict\n  values.forEach((value, index) => {\n    const key = bps[index]\n    if (value == null) return\n    result[key] = value\n  })\n  return result\n}\n\nexport function isResponsiveObjectLike(obj: Dict, bps = breakpoints) {\n  const keys = Object.keys(obj)\n  return keys.length > 0 && keys.every((key) => bps.includes(key))\n}\n\n/**\n * since breakpoints are defined as custom properties on an array, you may\n * `Object.keys(theme.breakpoints)` to retrieve both regular numeric indices\n * and custom breakpoints as string.\n *\n * This function returns true given a custom array property.\n */\nexport const isCustomBreakpoint = (maybeBreakpoint: string) =>\n  Number.isNaN(Number(maybeBreakpoint))\n"],"mappings":"AAAA,SAASA,WAAT,QAA4B,SAA5B;AACA,SAASC,OAAT,EAAkBC,QAAlB,QAAkC,aAAlC;AACA,SAASC,UAAT,QAA2B,UAA3B;AAGA,OAAO,IAAMC,WAAW,GAAGC,MAAM,CAACC,MAAP,CAAc,CACvC,MADuC,EAEvC,IAFuC,EAGvC,IAHuC,EAIvC,IAJuC,EAKvC,IALuC,EAMvC,KANuC,CAAd,CAApB;AASP,OAAO,SAASC,aAATA,CAAuBC,IAAvB,EAAkCC,MAAlC,EAA6D;EAClE,IAAIR,OAAO,CAACO,IAAD,CAAX,EAAmB;IACjB,OAAOA,IAAI,CAACE,GAAL,CAAUC,IAAD,IAAU;MACxB,IAAIA,IAAI,KAAK,IAAb,EAAmB;QACjB,OAAO,IAAP;MACD;MACD,OAAOF,MAAM,CAACE,IAAD,CAAb;IACD,CALM,CAAP;EAMD;EAED,IAAIT,QAAQ,CAACM,IAAD,CAAZ,EAAoB;IAClB,OAAOL,UAAU,CAACK,IAAD,CAAV,CAAiBI,MAAjB,CAAwB,CAACC,MAAD,EAAeC,GAAf,KAAuB;MACpDD,MAAM,CAACC,GAAD,CAAN,GAAcL,MAAM,CAACD,IAAI,CAACM,GAAD,CAAL,CAApB;MACA,OAAOD,MAAP;IACD,CAHM,EAGJ,EAHI,CAAP;EAID;EAED,IAAIL,IAAI,IAAI,IAAZ,EAAkB;IAChB,OAAOC,MAAM,CAACD,IAAD,CAAb;EACD;EAED,OAAO,IAAP;AACD;AAED,OAAO,SAASO,qBAATA,CAA+BC,GAA/B,EAA0CC,GAA1C,EAA6D;EAAA,IAAnBA,GAAmB;IAAnBA,GAAmB,GAAbb,WAAa;EAAA;EAClE,IAAMS,MAAM,GAAGI,GAAG,CAACP,GAAJ,CAASQ,EAAD;IAAA,IAAAC,OAAA;IAAA,QAAAA,OAAA,GAAQH,GAAG,CAACE,EAAD,CAAX,YAAAC,OAAA,GAAmB,IAAnB;EAAA,CAAR,CAAf;EACA,OAAOnB,WAAW,CAACa,MAAD,CAAX,KAAwB,IAA/B,EAAqC;IACnCA,MAAM,CAACO,GAAP;EACD;EACD,OAAOP,MAAP;AACD;AAED,OAAO,SAASQ,qBAATA,CAA+BC,MAA/B,EAA8CL,GAA9C,EAAiE;EAAA,IAAnBA,GAAmB;IAAnBA,GAAmB,GAAbb,WAAa;EAAA;EACtE,IAAMS,MAAM,GAAG,EAAf;EACAS,MAAM,CAACC,OAAP,CAAe,CAACC,KAAD,EAAQC,KAAR,KAAkB;IAC/B,IAAMX,GAAG,GAAGG,GAAG,CAACQ,KAAD,CAAf;IACA,IAAID,KAAK,IAAI,IAAb,EAAmB;IACnBX,MAAM,CAACC,GAAD,CAAN,GAAcU,KAAd;EACD,CAJD;EAKA,OAAOX,MAAP;AACD;AAED,OAAO,SAASa,sBAATA,CAAgCV,GAAhC,EAA2CC,GAA3C,EAA8D;EAAA,IAAnBA,GAAmB;IAAnBA,GAAmB,GAAbb,WAAa;EAAA;EACnE,IAAMuB,IAAI,GAAGtB,MAAM,CAACsB,IAAP,CAAYX,GAAZ,CAAb;EACA,OAAOW,IAAI,CAACC,MAAL,GAAc,CAAd,IAAmBD,IAAI,CAACE,KAAL,CAAYf,GAAD,IAASG,GAAG,CAACa,QAAJ,CAAahB,GAAb,CAApB,CAA1B;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAMiB,kBAAkB,GAAIC,eAAD,IAChCC,MAAM,CAACC,KAAP,CAAaD,MAAM,CAACD,eAAD,CAAnB,CADK"},"metadata":{},"sourceType":"module"}