{"ast":null,"code":"import { isNotNumber } from \"./assertion\";\nimport { warn } from \"./function\";\nexport var minSafeInteger = Number.MIN_SAFE_INTEGER || -9007199254740991;\nexport var maxSafeInteger = Number.MAX_SAFE_INTEGER || 9007199254740991;\nfunction toNumber(value) {\n  var num = parseFloat(value);\n  return isNotNumber(num) ? 0 : num;\n}\n/**\r\n * Converts a value to a specific precision (or decimal points).\r\n *\r\n * Returns a string representing a number in fixed-point notation.\r\n *\r\n * @param value the value to convert\r\n * @param precision the precision or decimal points\r\n */\n\nexport function toPrecision(value, precision) {\n  var nextValue = toNumber(value);\n  var scaleFactor = 10 ** (precision != null ? precision : 10);\n  nextValue = Math.round(nextValue * scaleFactor) / scaleFactor;\n  return precision ? nextValue.toFixed(precision) : nextValue.toString();\n}\n/**\r\n * Counts the number of decimal places a number has\r\n *\r\n * @param value the decimal value to count\r\n */\n\nexport function countDecimalPlaces(value) {\n  if (!Number.isFinite(value)) return 0;\n  var e = 1;\n  var p = 0;\n  while (Math.round(value * e) / e !== value) {\n    e *= 10;\n    p += 1;\n  }\n  return p;\n}\n/**\r\n * Convert a value to percentage based on lower and upper bound values\r\n *\r\n * @param value the value in number\r\n * @param min the minimum value\r\n * @param max the maximum value\r\n */\n\nexport function valueToPercent(value, min, max) {\n  return (value - min) * 100 / (max - min);\n}\n/**\r\n * Calculate the value based on percentage, lower and upper bound values\r\n *\r\n * @param percent the percent value in decimals (e.g 0.6, 0.3)\r\n * @param min the minimum value\r\n * @param max the maximum value\r\n */\n\nexport function percentToValue(percent, min, max) {\n  return (max - min) * percent + min;\n}\n/**\r\n * Rounds a specific value to the next or previous step\r\n *\r\n * @param value the value to round\r\n * @param from the number that stepping started from\r\n * @param step the specified step\r\n */\n\nexport function roundValueToStep(value, from, step) {\n  var nextValue = Math.round((value - from) / step) * step + from;\n  var precision = countDecimalPlaces(step);\n  return toPrecision(nextValue, precision);\n}\n/**\r\n * Clamps a value to ensure it stays within the min and max range.\r\n *\r\n * @param value the value to clamp\r\n * @param min the minimum value\r\n * @param max the maximum value\r\n */\n\nexport function clampValue(value, min, max) {\n  if (value == null) return value;\n  warn({\n    condition: max < min,\n    message: \"clamp: max cannot be less than min\"\n  });\n  return Math.min(Math.max(value, min), max);\n}","map":{"version":3,"names":["isNotNumber","warn","minSafeInteger","Number","MIN_SAFE_INTEGER","maxSafeInteger","MAX_SAFE_INTEGER","toNumber","value","num","parseFloat","toPrecision","precision","nextValue","scaleFactor","Math","round","toFixed","toString","countDecimalPlaces","isFinite","e","p","valueToPercent","min","max","percentToValue","percent","roundValueToStep","from","step","clampValue","condition","message"],"sources":["../../src/number.ts"],"sourcesContent":["import { isNotNumber } from \"./assertion\"\nimport { warn } from \"./function\"\n\nexport const minSafeInteger = Number.MIN_SAFE_INTEGER || -9007199254740991\nexport const maxSafeInteger = Number.MAX_SAFE_INTEGER || 9007199254740991\n\nfunction toNumber(value: any) {\n  const num = parseFloat(value)\n  return isNotNumber(num) ? 0 : num\n}\n\n/**\n * Converts a value to a specific precision (or decimal points).\n *\n * Returns a string representing a number in fixed-point notation.\n *\n * @param value the value to convert\n * @param precision the precision or decimal points\n */\nexport function toPrecision(value: number, precision?: number) {\n  let nextValue: string | number = toNumber(value)\n  const scaleFactor = 10 ** (precision ?? 10)\n  nextValue = Math.round(nextValue * scaleFactor) / scaleFactor\n  return precision ? nextValue.toFixed(precision) : nextValue.toString()\n}\n\n/**\n * Counts the number of decimal places a number has\n *\n * @param value the decimal value to count\n */\nexport function countDecimalPlaces(value: number) {\n  if (!Number.isFinite(value)) return 0\n\n  let e = 1\n  let p = 0\n  while (Math.round(value * e) / e !== value) {\n    e *= 10\n    p += 1\n  }\n  return p\n}\n\n/**\n * Convert a value to percentage based on lower and upper bound values\n *\n * @param value the value in number\n * @param min the minimum value\n * @param max the maximum value\n */\nexport function valueToPercent(value: number, min: number, max: number) {\n  return ((value - min) * 100) / (max - min)\n}\n\n/**\n * Calculate the value based on percentage, lower and upper bound values\n *\n * @param percent the percent value in decimals (e.g 0.6, 0.3)\n * @param min the minimum value\n * @param max the maximum value\n */\nexport function percentToValue(percent: number, min: number, max: number) {\n  return (max - min) * percent + min\n}\n\n/**\n * Rounds a specific value to the next or previous step\n *\n * @param value the value to round\n * @param from the number that stepping started from\n * @param step the specified step\n */\nexport function roundValueToStep(value: number, from: number, step: number) {\n  const nextValue = Math.round((value - from) / step) * step + from\n  const precision = countDecimalPlaces(step)\n  return toPrecision(nextValue, precision)\n}\n\n/**\n * Clamps a value to ensure it stays within the min and max range.\n *\n * @param value the value to clamp\n * @param min the minimum value\n * @param max the maximum value\n */\nexport function clampValue(value: number, min: number, max: number) {\n  if (value == null) return value\n\n  warn({\n    condition: max < min,\n    message: \"clamp: max cannot be less than min\",\n  })\n\n  return Math.min(Math.max(value, min), max)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}