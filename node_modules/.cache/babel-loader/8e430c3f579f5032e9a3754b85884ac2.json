{"ast":null,"code":"import { __spreadArray, __read, __assign, __rest } from 'tslib';\nimport { isAnimationControls } from '../../animation/utils/is-animation-controls.js';\nimport { isKeyframesTarget } from '../../animation/utils/is-keyframes-target.js';\nimport { shallowCompare } from '../../utils/shallow-compare.js';\nimport { animateVisualElement } from './animation.js';\nimport { AnimationType } from './types.js';\nimport { isVariantLabels, resolveVariant, isVariantLabel } from './variants.js';\nvar variantPriorityOrder = [AnimationType.Animate, AnimationType.Hover, AnimationType.Tap, AnimationType.Drag, AnimationType.Focus, AnimationType.Exit];\nvar reversePriorityOrder = __spreadArray([], __read(variantPriorityOrder)).reverse();\nvar numAnimationTypes = variantPriorityOrder.length;\nfunction animateList(visualElement) {\n  return function (animations) {\n    return Promise.all(animations.map(function (_a) {\n      var animation = _a.animation,\n        options = _a.options;\n      return animateVisualElement(visualElement, animation, options);\n    }));\n  };\n}\nfunction createAnimationState(visualElement) {\n  var animate = animateList(visualElement);\n  var state = createState();\n  var allAnimatedKeys = {};\n  var isInitialRender = true;\n  /**\r\n   * This function will be used to reduce the animation definitions for\r\n   * each active animation type into an object of resolved values for it.\r\n   */\n  var buildResolvedTypeValues = function (acc, definition) {\n    var resolved = resolveVariant(visualElement, definition);\n    if (resolved) {\n      resolved.transition;\n      var transitionEnd = resolved.transitionEnd,\n        target = __rest(resolved, [\"transition\", \"transitionEnd\"]);\n      acc = __assign(__assign(__assign({}, acc), target), transitionEnd);\n    }\n    return acc;\n  };\n  function isAnimated(key) {\n    return allAnimatedKeys[key] !== undefined;\n  }\n  /**\r\n   * This just allows us to inject mocked animation functions\r\n   * @internal\r\n   */\n  function setAnimateFunction(makeAnimator) {\n    animate = makeAnimator(visualElement);\n  }\n  /**\r\n   * When we receive new props, we need to:\r\n   * 1. Create a list of protected keys for each type. This is a directory of\r\n   *    value keys that are currently being \"handled\" by types of a higher priority\r\n   *    so that whenever an animation is played of a given type, these values are\r\n   *    protected from being animated.\r\n   * 2. Determine if an animation type needs animating.\r\n   * 3. Determine if any values have been removed from a type and figure out\r\n   *    what to animate those to.\r\n   */\n  function animateChanges(options, changedActiveType) {\n    var _a;\n    var props = visualElement.getProps();\n    var context = visualElement.getVariantContext(true) || {};\n    /**\r\n     * A list of animations that we'll build into as we iterate through the animation\r\n     * types. This will get executed at the end of the function.\r\n     */\n    var animations = [];\n    /**\r\n     * Keep track of which values have been removed. Then, as we hit lower priority\r\n     * animation types, we can check if they contain removed values and animate to that.\r\n     */\n    var removedKeys = new Set();\n    /**\r\n     * A dictionary of all encountered keys. This is an object to let us build into and\r\n     * copy it without iteration. Each time we hit an animation type we set its protected\r\n     * keys - the keys its not allowed to animate - to the latest version of this object.\r\n     */\n    var encounteredKeys = {};\n    /**\r\n     * If a variant has been removed at a given index, and this component is controlling\r\n     * variant animations, we want to ensure lower-priority variants are forced to animate.\r\n     */\n    var removedVariantIndex = Infinity;\n    var _loop_1 = function (i) {\n      var type = reversePriorityOrder[i];\n      var typeState = state[type];\n      var prop = (_a = props[type]) !== null && _a !== void 0 ? _a : context[type];\n      var propIsVariant = isVariantLabel(prop);\n      /**\r\n       * If this type has *just* changed isActive status, set activeDelta\r\n       * to that status. Otherwise set to null.\r\n       */\n      var activeDelta = type === changedActiveType ? typeState.isActive : null;\n      if (activeDelta === false) removedVariantIndex = i;\n      /**\r\n       * If this prop is an inherited variant, rather than been set directly on the\r\n       * component itself, we want to make sure we allow the parent to trigger animations.\r\n       *\r\n       * TODO: Can probably change this to a !isControllingVariants check\r\n       */\n      var isInherited = prop === context[type] && prop !== props[type] && propIsVariant;\n      /**\r\n       *\r\n       */\n      if (isInherited && isInitialRender && visualElement.manuallyAnimateOnMount) {\n        isInherited = false;\n      }\n      /**\r\n       * Set all encountered keys so far as the protected keys for this type. This will\r\n       * be any key that has been animated or otherwise handled by active, higher-priortiy types.\r\n       */\n      typeState.protectedKeys = __assign({}, encounteredKeys);\n      // Check if we can skip analysing this prop early\n      if (\n      // If it isn't active and hasn't *just* been set as inactive\n      !typeState.isActive && activeDelta === null ||\n      // If we didn't and don't have any defined prop for this animation type\n      !prop && !typeState.prevProp ||\n      // Or if the prop doesn't define an animation\n      isAnimationControls(prop) || typeof prop === \"boolean\") {\n        return \"continue\";\n      }\n      /**\r\n       * As we go look through the values defined on this type, if we detect\r\n       * a changed value or a value that was removed in a higher priority, we set\r\n       * this to true and add this prop to the animation list.\r\n       */\n      var shouldAnimateType = variantsHaveChanged(typeState.prevProp, prop) ||\n      // If we're making this variant active, we want to always make it active\n      type === changedActiveType && typeState.isActive && !isInherited && propIsVariant ||\n      // If we removed a higher-priority variant (i is in reverse order)\n      i > removedVariantIndex && propIsVariant;\n      /**\r\n       * As animations can be set as variant lists, variants or target objects, we\r\n       * coerce everything to an array if it isn't one already\r\n       */\n      var definitionList = Array.isArray(prop) ? prop : [prop];\n      /**\r\n       * Build an object of all the resolved values. We'll use this in the subsequent\r\n       * animateChanges calls to determine whether a value has changed.\r\n       */\n      var resolvedValues = definitionList.reduce(buildResolvedTypeValues, {});\n      if (activeDelta === false) resolvedValues = {};\n      /**\r\n       * Now we need to loop through all the keys in the prev prop and this prop,\r\n       * and decide:\r\n       * 1. If the value has changed, and needs animating\r\n       * 2. If it has been removed, and needs adding to the removedKeys set\r\n       * 3. If it has been removed in a higher priority type and needs animating\r\n       * 4. If it hasn't been removed in a higher priority but hasn't changed, and\r\n       *    needs adding to the type's protectedKeys list.\r\n       */\n      var _b = typeState.prevResolvedValues,\n        prevResolvedValues = _b === void 0 ? {} : _b;\n      var allKeys = __assign(__assign({}, prevResolvedValues), resolvedValues);\n      var markToAnimate = function (key) {\n        shouldAnimateType = true;\n        removedKeys.delete(key);\n        typeState.needsAnimating[key] = true;\n      };\n      for (var key in allKeys) {\n        var next = resolvedValues[key];\n        var prev = prevResolvedValues[key];\n        // If we've already handled this we can just skip ahead\n        if (encounteredKeys.hasOwnProperty(key)) continue;\n        /**\r\n         * If the value has changed, we probably want to animate it.\r\n         */\n        if (next !== prev) {\n          /**\r\n           * If both values are keyframes, we need to shallow compare them to\r\n           * detect whether any value has changed. If it has, we animate it.\r\n           */\n          if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {\n            if (!shallowCompare(next, prev)) {\n              markToAnimate(key);\n            } else {\n              /**\r\n               * If it hasn't changed, we want to ensure it doesn't animate by\r\n               * adding it to the list of protected keys.\r\n               */\n              typeState.protectedKeys[key] = true;\n            }\n          } else if (next !== undefined) {\n            // If next is defined and doesn't equal prev, it needs animating\n            markToAnimate(key);\n          } else {\n            // If it's undefined, it's been removed.\n            removedKeys.add(key);\n          }\n        } else if (next !== undefined && removedKeys.has(key)) {\n          /**\r\n           * If next hasn't changed and it isn't undefined, we want to check if it's\r\n           * been removed by a higher priority\r\n           */\n          markToAnimate(key);\n        } else {\n          /**\r\n           * If it hasn't changed, we add it to the list of protected values\r\n           * to ensure it doesn't get animated.\r\n           */\n          typeState.protectedKeys[key] = true;\n        }\n      }\n      /**\r\n       * Update the typeState so next time animateChanges is called we can compare the\r\n       * latest prop and resolvedValues to these.\r\n       */\n      typeState.prevProp = prop;\n      typeState.prevResolvedValues = resolvedValues;\n      /**\r\n       *\r\n       */\n      if (typeState.isActive) {\n        encounteredKeys = __assign(__assign({}, encounteredKeys), resolvedValues);\n      }\n      if (isInitialRender && visualElement.blockInitialAnimation) {\n        shouldAnimateType = false;\n      }\n      /**\r\n       * If this is an inherited prop we want to hard-block animations\r\n       * TODO: Test as this should probably still handle animations triggered\r\n       * by removed values?\r\n       */\n      if (shouldAnimateType && !isInherited) {\n        animations.push.apply(animations, __spreadArray([], __read(definitionList.map(function (animation) {\n          return {\n            animation: animation,\n            options: __assign({\n              type: type\n            }, options)\n          };\n        }))));\n      }\n    };\n    /**\r\n     * Iterate through all animation types in reverse priority order. For each, we want to\r\n     * detect which values it's handling and whether or not they've changed (and therefore\r\n     * need to be animated). If any values have been removed, we want to detect those in\r\n     * lower priority props and flag for animation.\r\n     */\n    for (var i = 0; i < numAnimationTypes; i++) {\n      _loop_1(i);\n    }\n    allAnimatedKeys = __assign({}, encounteredKeys);\n    /**\r\n     * If there are some removed value that haven't been dealt with,\r\n     * we need to create a new animation that falls back either to the value\r\n     * defined in the style prop, or the last read value.\r\n     */\n    if (removedKeys.size) {\n      var fallbackAnimation_1 = {};\n      removedKeys.forEach(function (key) {\n        var fallbackTarget = visualElement.getBaseTarget(key);\n        if (fallbackTarget !== undefined) {\n          fallbackAnimation_1[key] = fallbackTarget;\n        }\n      });\n      animations.push({\n        animation: fallbackAnimation_1\n      });\n    }\n    var shouldAnimate = Boolean(animations.length);\n    if (isInitialRender && props.initial === false && !visualElement.manuallyAnimateOnMount) {\n      shouldAnimate = false;\n    }\n    isInitialRender = false;\n    return shouldAnimate ? animate(animations) : Promise.resolve();\n  }\n  /**\r\n   * Change whether a certain animation type is active.\r\n   */\n  function setActive(type, isActive, options) {\n    var _a;\n    // If the active state hasn't changed, we can safely do nothing here\n    if (state[type].isActive === isActive) return Promise.resolve();\n    // Propagate active change to children\n    (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach(function (child) {\n      var _a;\n      return (_a = child.animationState) === null || _a === void 0 ? void 0 : _a.setActive(type, isActive);\n    });\n    state[type].isActive = isActive;\n    return animateChanges(options, type);\n  }\n  return {\n    isAnimated: isAnimated,\n    animateChanges: animateChanges,\n    setActive: setActive,\n    setAnimateFunction: setAnimateFunction,\n    getState: function () {\n      return state;\n    }\n  };\n}\nfunction variantsHaveChanged(prev, next) {\n  if (typeof next === \"string\") {\n    return next !== prev;\n  } else if (isVariantLabels(next)) {\n    return !shallowCompare(next, prev);\n  }\n  return false;\n}\nfunction createTypeState(isActive) {\n  if (isActive === void 0) {\n    isActive = false;\n  }\n  return {\n    isActive: isActive,\n    protectedKeys: {},\n    needsAnimating: {},\n    prevResolvedValues: {}\n  };\n}\nfunction createState() {\n  var _a;\n  return _a = {}, _a[AnimationType.Animate] = createTypeState(true), _a[AnimationType.Hover] = createTypeState(), _a[AnimationType.Tap] = createTypeState(), _a[AnimationType.Drag] = createTypeState(), _a[AnimationType.Focus] = createTypeState(), _a[AnimationType.Exit] = createTypeState(), _a;\n}\nexport { createAnimationState, variantPriorityOrder, variantsHaveChanged };","map":{"version":3,"names":["__spreadArray","__read","__assign","__rest","isAnimationControls","isKeyframesTarget","shallowCompare","animateVisualElement","AnimationType","isVariantLabels","resolveVariant","isVariantLabel","variantPriorityOrder","Animate","Hover","Tap","Drag","Focus","Exit","reversePriorityOrder","reverse","numAnimationTypes","length","animateList","visualElement","animations","Promise","all","map","_a","animation","options","createAnimationState","animate","state","createState","allAnimatedKeys","isInitialRender","buildResolvedTypeValues","acc","definition","resolved","transition","transitionEnd","target","isAnimated","key","undefined","setAnimateFunction","makeAnimator","animateChanges","changedActiveType","props","getProps","context","getVariantContext","removedKeys","Set","encounteredKeys","removedVariantIndex","Infinity","_loop_1","i","type","typeState","prop","propIsVariant","activeDelta","isActive","isInherited","manuallyAnimateOnMount","protectedKeys","prevProp","shouldAnimateType","variantsHaveChanged","definitionList","Array","isArray","resolvedValues","reduce","_b","prevResolvedValues","allKeys","markToAnimate","delete","needsAnimating","next","prev","hasOwnProperty","add","has","blockInitialAnimation","push","apply","size","fallbackAnimation_1","forEach","fallbackTarget","getBaseTarget","shouldAnimate","Boolean","initial","resolve","setActive","variantChildren","child","animationState","getState","createTypeState"],"sources":["E:/Hasan sir project/frontend/node_modules/framer-motion/dist/es/render/utils/animation-state.js"],"sourcesContent":["import { __spreadArray, __read, __assign, __rest } from 'tslib';\r\nimport { isAnimationControls } from '../../animation/utils/is-animation-controls.js';\r\nimport { isKeyframesTarget } from '../../animation/utils/is-keyframes-target.js';\r\nimport { shallowCompare } from '../../utils/shallow-compare.js';\r\nimport { animateVisualElement } from './animation.js';\r\nimport { AnimationType } from './types.js';\r\nimport { isVariantLabels, resolveVariant, isVariantLabel } from './variants.js';\r\n\r\nvar variantPriorityOrder = [\r\n    AnimationType.Animate,\r\n    AnimationType.Hover,\r\n    AnimationType.Tap,\r\n    AnimationType.Drag,\r\n    AnimationType.Focus,\r\n    AnimationType.Exit,\r\n];\r\nvar reversePriorityOrder = __spreadArray([], __read(variantPriorityOrder)).reverse();\r\nvar numAnimationTypes = variantPriorityOrder.length;\r\nfunction animateList(visualElement) {\r\n    return function (animations) {\r\n        return Promise.all(animations.map(function (_a) {\r\n            var animation = _a.animation, options = _a.options;\r\n            return animateVisualElement(visualElement, animation, options);\r\n        }));\r\n    };\r\n}\r\nfunction createAnimationState(visualElement) {\r\n    var animate = animateList(visualElement);\r\n    var state = createState();\r\n    var allAnimatedKeys = {};\r\n    var isInitialRender = true;\r\n    /**\r\n     * This function will be used to reduce the animation definitions for\r\n     * each active animation type into an object of resolved values for it.\r\n     */\r\n    var buildResolvedTypeValues = function (acc, definition) {\r\n        var resolved = resolveVariant(visualElement, definition);\r\n        if (resolved) {\r\n            resolved.transition; var transitionEnd = resolved.transitionEnd, target = __rest(resolved, [\"transition\", \"transitionEnd\"]);\r\n            acc = __assign(__assign(__assign({}, acc), target), transitionEnd);\r\n        }\r\n        return acc;\r\n    };\r\n    function isAnimated(key) {\r\n        return allAnimatedKeys[key] !== undefined;\r\n    }\r\n    /**\r\n     * This just allows us to inject mocked animation functions\r\n     * @internal\r\n     */\r\n    function setAnimateFunction(makeAnimator) {\r\n        animate = makeAnimator(visualElement);\r\n    }\r\n    /**\r\n     * When we receive new props, we need to:\r\n     * 1. Create a list of protected keys for each type. This is a directory of\r\n     *    value keys that are currently being \"handled\" by types of a higher priority\r\n     *    so that whenever an animation is played of a given type, these values are\r\n     *    protected from being animated.\r\n     * 2. Determine if an animation type needs animating.\r\n     * 3. Determine if any values have been removed from a type and figure out\r\n     *    what to animate those to.\r\n     */\r\n    function animateChanges(options, changedActiveType) {\r\n        var _a;\r\n        var props = visualElement.getProps();\r\n        var context = visualElement.getVariantContext(true) || {};\r\n        /**\r\n         * A list of animations that we'll build into as we iterate through the animation\r\n         * types. This will get executed at the end of the function.\r\n         */\r\n        var animations = [];\r\n        /**\r\n         * Keep track of which values have been removed. Then, as we hit lower priority\r\n         * animation types, we can check if they contain removed values and animate to that.\r\n         */\r\n        var removedKeys = new Set();\r\n        /**\r\n         * A dictionary of all encountered keys. This is an object to let us build into and\r\n         * copy it without iteration. Each time we hit an animation type we set its protected\r\n         * keys - the keys its not allowed to animate - to the latest version of this object.\r\n         */\r\n        var encounteredKeys = {};\r\n        /**\r\n         * If a variant has been removed at a given index, and this component is controlling\r\n         * variant animations, we want to ensure lower-priority variants are forced to animate.\r\n         */\r\n        var removedVariantIndex = Infinity;\r\n        var _loop_1 = function (i) {\r\n            var type = reversePriorityOrder[i];\r\n            var typeState = state[type];\r\n            var prop = (_a = props[type]) !== null && _a !== void 0 ? _a : context[type];\r\n            var propIsVariant = isVariantLabel(prop);\r\n            /**\r\n             * If this type has *just* changed isActive status, set activeDelta\r\n             * to that status. Otherwise set to null.\r\n             */\r\n            var activeDelta = type === changedActiveType ? typeState.isActive : null;\r\n            if (activeDelta === false)\r\n                removedVariantIndex = i;\r\n            /**\r\n             * If this prop is an inherited variant, rather than been set directly on the\r\n             * component itself, we want to make sure we allow the parent to trigger animations.\r\n             *\r\n             * TODO: Can probably change this to a !isControllingVariants check\r\n             */\r\n            var isInherited = prop === context[type] && prop !== props[type] && propIsVariant;\r\n            /**\r\n             *\r\n             */\r\n            if (isInherited &&\r\n                isInitialRender &&\r\n                visualElement.manuallyAnimateOnMount) {\r\n                isInherited = false;\r\n            }\r\n            /**\r\n             * Set all encountered keys so far as the protected keys for this type. This will\r\n             * be any key that has been animated or otherwise handled by active, higher-priortiy types.\r\n             */\r\n            typeState.protectedKeys = __assign({}, encounteredKeys);\r\n            // Check if we can skip analysing this prop early\r\n            if (\r\n            // If it isn't active and hasn't *just* been set as inactive\r\n            (!typeState.isActive && activeDelta === null) ||\r\n                // If we didn't and don't have any defined prop for this animation type\r\n                (!prop && !typeState.prevProp) ||\r\n                // Or if the prop doesn't define an animation\r\n                isAnimationControls(prop) ||\r\n                typeof prop === \"boolean\") {\r\n                return \"continue\";\r\n            }\r\n            /**\r\n             * As we go look through the values defined on this type, if we detect\r\n             * a changed value or a value that was removed in a higher priority, we set\r\n             * this to true and add this prop to the animation list.\r\n             */\r\n            var shouldAnimateType = variantsHaveChanged(typeState.prevProp, prop) ||\r\n                // If we're making this variant active, we want to always make it active\r\n                (type === changedActiveType &&\r\n                    typeState.isActive &&\r\n                    !isInherited &&\r\n                    propIsVariant) ||\r\n                // If we removed a higher-priority variant (i is in reverse order)\r\n                (i > removedVariantIndex && propIsVariant);\r\n            /**\r\n             * As animations can be set as variant lists, variants or target objects, we\r\n             * coerce everything to an array if it isn't one already\r\n             */\r\n            var definitionList = Array.isArray(prop) ? prop : [prop];\r\n            /**\r\n             * Build an object of all the resolved values. We'll use this in the subsequent\r\n             * animateChanges calls to determine whether a value has changed.\r\n             */\r\n            var resolvedValues = definitionList.reduce(buildResolvedTypeValues, {});\r\n            if (activeDelta === false)\r\n                resolvedValues = {};\r\n            /**\r\n             * Now we need to loop through all the keys in the prev prop and this prop,\r\n             * and decide:\r\n             * 1. If the value has changed, and needs animating\r\n             * 2. If it has been removed, and needs adding to the removedKeys set\r\n             * 3. If it has been removed in a higher priority type and needs animating\r\n             * 4. If it hasn't been removed in a higher priority but hasn't changed, and\r\n             *    needs adding to the type's protectedKeys list.\r\n             */\r\n            var _b = typeState.prevResolvedValues, prevResolvedValues = _b === void 0 ? {} : _b;\r\n            var allKeys = __assign(__assign({}, prevResolvedValues), resolvedValues);\r\n            var markToAnimate = function (key) {\r\n                shouldAnimateType = true;\r\n                removedKeys.delete(key);\r\n                typeState.needsAnimating[key] = true;\r\n            };\r\n            for (var key in allKeys) {\r\n                var next = resolvedValues[key];\r\n                var prev = prevResolvedValues[key];\r\n                // If we've already handled this we can just skip ahead\r\n                if (encounteredKeys.hasOwnProperty(key))\r\n                    continue;\r\n                /**\r\n                 * If the value has changed, we probably want to animate it.\r\n                 */\r\n                if (next !== prev) {\r\n                    /**\r\n                     * If both values are keyframes, we need to shallow compare them to\r\n                     * detect whether any value has changed. If it has, we animate it.\r\n                     */\r\n                    if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {\r\n                        if (!shallowCompare(next, prev)) {\r\n                            markToAnimate(key);\r\n                        }\r\n                        else {\r\n                            /**\r\n                             * If it hasn't changed, we want to ensure it doesn't animate by\r\n                             * adding it to the list of protected keys.\r\n                             */\r\n                            typeState.protectedKeys[key] = true;\r\n                        }\r\n                    }\r\n                    else if (next !== undefined) {\r\n                        // If next is defined and doesn't equal prev, it needs animating\r\n                        markToAnimate(key);\r\n                    }\r\n                    else {\r\n                        // If it's undefined, it's been removed.\r\n                        removedKeys.add(key);\r\n                    }\r\n                }\r\n                else if (next !== undefined && removedKeys.has(key)) {\r\n                    /**\r\n                     * If next hasn't changed and it isn't undefined, we want to check if it's\r\n                     * been removed by a higher priority\r\n                     */\r\n                    markToAnimate(key);\r\n                }\r\n                else {\r\n                    /**\r\n                     * If it hasn't changed, we add it to the list of protected values\r\n                     * to ensure it doesn't get animated.\r\n                     */\r\n                    typeState.protectedKeys[key] = true;\r\n                }\r\n            }\r\n            /**\r\n             * Update the typeState so next time animateChanges is called we can compare the\r\n             * latest prop and resolvedValues to these.\r\n             */\r\n            typeState.prevProp = prop;\r\n            typeState.prevResolvedValues = resolvedValues;\r\n            /**\r\n             *\r\n             */\r\n            if (typeState.isActive) {\r\n                encounteredKeys = __assign(__assign({}, encounteredKeys), resolvedValues);\r\n            }\r\n            if (isInitialRender && visualElement.blockInitialAnimation) {\r\n                shouldAnimateType = false;\r\n            }\r\n            /**\r\n             * If this is an inherited prop we want to hard-block animations\r\n             * TODO: Test as this should probably still handle animations triggered\r\n             * by removed values?\r\n             */\r\n            if (shouldAnimateType && !isInherited) {\r\n                animations.push.apply(animations, __spreadArray([], __read(definitionList.map(function (animation) { return ({\r\n                    animation: animation,\r\n                    options: __assign({ type: type }, options),\r\n                }); }))));\r\n            }\r\n        };\r\n        /**\r\n         * Iterate through all animation types in reverse priority order. For each, we want to\r\n         * detect which values it's handling and whether or not they've changed (and therefore\r\n         * need to be animated). If any values have been removed, we want to detect those in\r\n         * lower priority props and flag for animation.\r\n         */\r\n        for (var i = 0; i < numAnimationTypes; i++) {\r\n            _loop_1(i);\r\n        }\r\n        allAnimatedKeys = __assign({}, encounteredKeys);\r\n        /**\r\n         * If there are some removed value that haven't been dealt with,\r\n         * we need to create a new animation that falls back either to the value\r\n         * defined in the style prop, or the last read value.\r\n         */\r\n        if (removedKeys.size) {\r\n            var fallbackAnimation_1 = {};\r\n            removedKeys.forEach(function (key) {\r\n                var fallbackTarget = visualElement.getBaseTarget(key);\r\n                if (fallbackTarget !== undefined) {\r\n                    fallbackAnimation_1[key] = fallbackTarget;\r\n                }\r\n            });\r\n            animations.push({ animation: fallbackAnimation_1 });\r\n        }\r\n        var shouldAnimate = Boolean(animations.length);\r\n        if (isInitialRender &&\r\n            props.initial === false &&\r\n            !visualElement.manuallyAnimateOnMount) {\r\n            shouldAnimate = false;\r\n        }\r\n        isInitialRender = false;\r\n        return shouldAnimate ? animate(animations) : Promise.resolve();\r\n    }\r\n    /**\r\n     * Change whether a certain animation type is active.\r\n     */\r\n    function setActive(type, isActive, options) {\r\n        var _a;\r\n        // If the active state hasn't changed, we can safely do nothing here\r\n        if (state[type].isActive === isActive)\r\n            return Promise.resolve();\r\n        // Propagate active change to children\r\n        (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach(function (child) { var _a; return (_a = child.animationState) === null || _a === void 0 ? void 0 : _a.setActive(type, isActive); });\r\n        state[type].isActive = isActive;\r\n        return animateChanges(options, type);\r\n    }\r\n    return {\r\n        isAnimated: isAnimated,\r\n        animateChanges: animateChanges,\r\n        setActive: setActive,\r\n        setAnimateFunction: setAnimateFunction,\r\n        getState: function () { return state; },\r\n    };\r\n}\r\nfunction variantsHaveChanged(prev, next) {\r\n    if (typeof next === \"string\") {\r\n        return next !== prev;\r\n    }\r\n    else if (isVariantLabels(next)) {\r\n        return !shallowCompare(next, prev);\r\n    }\r\n    return false;\r\n}\r\nfunction createTypeState(isActive) {\r\n    if (isActive === void 0) { isActive = false; }\r\n    return {\r\n        isActive: isActive,\r\n        protectedKeys: {},\r\n        needsAnimating: {},\r\n        prevResolvedValues: {},\r\n    };\r\n}\r\nfunction createState() {\r\n    var _a;\r\n    return _a = {},\r\n        _a[AnimationType.Animate] = createTypeState(true),\r\n        _a[AnimationType.Hover] = createTypeState(),\r\n        _a[AnimationType.Tap] = createTypeState(),\r\n        _a[AnimationType.Drag] = createTypeState(),\r\n        _a[AnimationType.Focus] = createTypeState(),\r\n        _a[AnimationType.Exit] = createTypeState(),\r\n        _a;\r\n}\r\n\r\nexport { createAnimationState, variantPriorityOrder, variantsHaveChanged };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}